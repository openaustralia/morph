# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq-limit_fetch` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq-limit_fetch`.

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/queue.rb:1
module Sidekiq
  class << self
    # How frequently Redis should be checked by a random Sidekiq process for
    # scheduled and retriable jobs. Each individual process will take turns by
    # waiting some multiple of this value.
    #
    # See sidekiq/scheduled.rb for an in-depth explanation of this value
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:199
    def average_scheduled_poll_interval=(interval); end

    # @yield [@client_chain]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:137
    def client_middleware; end

    # Configuration for Sidekiq client, use like:
    #
    #   Sidekiq.configure_client do |config|
    #     config.redis = { :namespace => 'myapp', :size => 1, :url => 'redis://myhost:8877/0' }
    #   end
    #
    # @yield [_self]
    # @yieldparam _self [Sidekiq] the object that the method was called on
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:84
    def configure_client; end

    # Configuration for Sidekiq server, use like:
    #
    #   Sidekiq.configure_server do |config|
    #     config.redis = { :namespace => 'myapp', :size => 25, :url => 'redis://myhost:8877/0' }
    #     config.server_middleware do |chain|
    #       chain.add MyServerHook
    #     end
    #   end
    #
    # @yield [_self]
    # @yieldparam _self [Sidekiq] the object that the method was called on
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:74
    def configure_server; end

    # Death handlers are called when all retries for a job have been exhausted and
    # the job dies.  It's the notification to your application
    # that this job will not succeed without manual intervention.
    #
    # Sidekiq.configure_server do |config|
    #   config.death_handlers << ->(job, ex) do
    #   end
    # end
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:176
    def death_handlers; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:161
    def default_retries_exhausted=(prok); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:149
    def default_server_middleware; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:157
    def default_worker_options; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:153
    def default_worker_options=(hash); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:183
    def dump_json(object); end

    # Register a proc to handle any error which occurs within the Sidekiq process.
    #
    #   Sidekiq.configure_server do |config|
    #     config.error_handlers << proc {|ex,ctx_hash| MyErrorService.notify(ex, ctx_hash) }
    #   end
    #
    # The default error handler logs errors to Sidekiq.logger.
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:210
    def error_handlers; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:180
    def load_json(string); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:187
    def logger; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:190
    def logger=(log); end

    # Register a block to run at a point in the Sidekiq lifecycle.
    # :startup, :quiet or :shutdown are valid events.
    #
    #   Sidekiq.configure_server do |config|
    #     config.on(:shutdown) do
    #       puts "Goodbye cruel world!"
    #     end
    #   end
    #
    # @raise [ArgumentError]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:222
    def on(event, &block); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:57
    def options; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:61
    def options=(opts); end

    # @raise [ArgumentError]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:92
    def redis; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:129
    def redis=(hash); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:107
    def redis_info; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:125
    def redis_pool; end

    # @return [Boolean]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:88
    def server?; end

    # @yield [@server_chain]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:143
    def server_middleware; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:53
    def â¨â•¯Â°â–¡Â°â©â•¯ï¸µâ”»â”â”»; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq.rb:18
Sidekiq::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://sidekiq-5.2.10/lib/sidekiq.rb:40
Sidekiq::DEFAULT_WORKER_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://sidekiq-5.2.10/lib/sidekiq.rb:45
Sidekiq::FAKE_INFO = T.let(T.unsafe(nil), Hash)

# source://sidekiq-5.2.10/lib/sidekiq.rb:16
Sidekiq::LICENSE = T.let(T.unsafe(nil), String)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch.rb:6
module Sidekiq::LimitFetch
  extend ::Sidekiq::LimitFetch

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch.rb:29
  def bulk_requeue(*args); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch.rb:19
  def new(_); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch.rb:33
  def redis_retryable; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch.rb:23
  def retrieve_work; end

  private

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch.rb:44
  def redis_brpop(queues); end
end

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:1
module Sidekiq::LimitFetch::Global; end

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:2
module Sidekiq::LimitFetch::Global::Monitor
  extend ::Sidekiq::LimitFetch::Global::Monitor

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:40
  def add_dynamic_queues; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:24
  def all_processes; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:28
  def old_processes; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:34
  def remove_old_processes!; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:10
  def start!(ttl = T.unsafe(nil), timeout = T.unsafe(nil)); end

  private

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:68
  def heartbeat_key(process = T.unsafe(nil)); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:57
  def invalidate_old_processes; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:47
  def update_heartbeat(ttl); end
end

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:5
Sidekiq::LimitFetch::Global::Monitor::HEARTBEAT_PREFIX = T.let(T.unsafe(nil), String)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:7
Sidekiq::LimitFetch::Global::Monitor::HEARTBEAT_TTL = T.let(T.unsafe(nil), Integer)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:6
Sidekiq::LimitFetch::Global::Monitor::PROCESS_SET = T.let(T.unsafe(nil), String)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/monitor.rb:8
Sidekiq::LimitFetch::Global::Monitor::REFRESH_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:2
module Sidekiq::LimitFetch::Global::Selector
  extend ::Sidekiq::LimitFetch::Global::Selector

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:7
  def acquire(queues, namespace); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:11
  def release(queues, namespace); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:15
  def uuid; end

  private

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:44
  def redis_acquire_script; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:36
  def redis_acquire_sha; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:25
  def redis_eval(script_name, args); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:112
  def redis_release_script; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:40
  def redis_release_sha; end
end

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/selector.rb:5
Sidekiq::LimitFetch::Global::Selector::MUTEX_FOR_UUID = T.let(T.unsafe(nil), Thread::Mutex)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:2
class Sidekiq::LimitFetch::Global::Semaphore
  # @return [Semaphore] a new instance of Semaphore
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:7
  def initialize(name); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:45
  def acquire; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:95
  def block; end

  # @raise [ArgumentError]
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:99
  def block_except(*queues); end

  # @return [Boolean]
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:108
  def blocking?; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:53
  def busy; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:57
  def busy_processes; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:66
  def decrease_busy; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:116
  def decrease_local_busy; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:124
  def explain; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:61
  def increase_busy; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:112
  def increase_local_busy; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:13
  def limit; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:18
  def limit=(value); end

  # @return [Boolean]
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:28
  def limit_changed?; end

  # Returns the value of attribute local_busy.
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:5
  def local_busy; end

  # @return [Boolean]
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:120
  def local_busy?; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:79
  def pause; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:83
  def pause_for_ms(ms); end

  # @return [Boolean]
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:91
  def paused?; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:71
  def probed; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:75
  def probed_processes; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:32
  def process_limit; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:37
  def process_limit=(value); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:49
  def release; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:158
  def remove_lock!(process); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:151
  def remove_locks_except!(processes); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:104
  def unblock; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:87
  def unpause; end

  private

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:171
  def namespace; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:167
  def redis(&block); end
end

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/global/semaphore.rb:3
Sidekiq::LimitFetch::Global::Semaphore::PREFIX = T.let(T.unsafe(nil), String)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/instances.rb:1
module Sidekiq::LimitFetch::Instances
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/instances.rb:6
  def [](*args); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/instances.rb:12
  def instances; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/instances.rb:6
  def new(*args); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/instances.rb:16
  def reset_instances!; end

  class << self
    # @private
    #
    # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/instances.rb:2
    def extended(klass); end
  end
end

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:1
module Sidekiq::LimitFetch::Queues
  extend ::Sidekiq::LimitFetch::Queues

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:21
  def acquire; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:40
  def add(queues); end

  # @return [Boolean]
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:36
  def dynamic?; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:60
  def namespace; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:27
  def release_except(full_name); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:6
  def start(options); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:51
  def strict_order!; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:56
  def weighted_order!; end

  private

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:97
  def apply_blocks_to_queues; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:89
  def apply_limit_to_queue(queue_name); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:83
  def apply_limit_to_queues; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:78
  def apply_process_limit_to_queue(queue_name); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:72
  def apply_process_limit_to_queues; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:119
  def restore; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:115
  def save(queues); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:111
  def selector; end
end

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/queues.rb:4
Sidekiq::LimitFetch::Queues::THREAD_KEY = T.let(T.unsafe(nil), Symbol)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch.rb:42
Sidekiq::LimitFetch::TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/unit_of_work.rb:2
class Sidekiq::LimitFetch::UnitOfWork < ::Sidekiq::BasicFetch::UnitOfWork
  # @return [UnitOfWork] a new instance of UnitOfWork
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/unit_of_work.rb:3
  def initialize(queue, job); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/unit_of_work.rb:8
  def acknowledge; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/unit_of_work.rb:13
  def requeue; end

  private

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/limit_fetch/unit_of_work.rb:20
  def redis_retryable(&block); end
end

# The Manager is the central coordination point in Sidekiq, controlling
# the lifecycle of the Processors.
#
# Tasks:
#
# 1. start: Spin up Processors.
# 3. processor_died: Handle job failure, throw away Processor, create new one.
# 4. quiet: shutdown idle Processors.
# 5. stop: hard stop the Processors by deadline.
#
# Note that only the last task requires its own Thread since it has to monitor
# the shutdown process.  The other tasks are performed by other threads.
#
# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/manager.rb:1
class Sidekiq::Manager
  include ::Sidekiq::Manager::InitLimitFetch
  include ::Sidekiq::ExceptionHandler

  # @raise [ArgumentError]
  # @return [Manager] a new instance of Manager
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/manager.rb:3
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute options.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:28
  def options; end

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:90
  def processor_died(processor, reason); end

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:84
  def processor_stopped(processor); end

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:50
  def quiet; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/manager.rb:8
  def start; end

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:62
  def stop(deadline); end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:101
  def stopped?; end

  # Returns the value of attribute workers.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:27
  def workers; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:107
  def hard_shutdown; end
end

# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/manager.rb:2
module Sidekiq::Manager::InitLimitFetch
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/manager.rb:3
  def initialize(options = T.unsafe(nil)); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/manager.rb:8
  def start; end
end

# hack for quicker development / testing environment #2774
#
# source://sidekiq-5.2.10/lib/sidekiq/manager.rb:60
Sidekiq::Manager::PAUSE_TIME = T.let(T.unsafe(nil), Float)

# source://sidekiq-5.2.10/lib/sidekiq.rb:15
Sidekiq::NAME = T.let(T.unsafe(nil), String)

# Encapsulates a queue within Sidekiq.
# Allows enumeration of all jobs within the queue
# and deletion of jobs.
#
#   queue = Sidekiq::Queue.new("mailer")
#   queue.each do |job|
#     job.klass # => 'MyWorker'
#     job.args # => [1, 2, 3]
#     job.delete if job.jid == 'abcdef1234567890'
#   end
#
# source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/queue.rb:2
class Sidekiq::Queue
  extend ::Forwardable
  extend ::Sidekiq::LimitFetch::Instances

  # @return [Queue] a new instance of Queue
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:238
  def initialize(name = T.unsafe(nil)); end

  # source://RUBY_ROOT/forwardable.rb:226
  def acquire(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def block(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def block_except(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def blocking?(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def busy(*args, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:298
  def clear; end

  # source://RUBY_ROOT/forwardable.rb:226
  def decrease_busy(*args, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:268
  def each; end

  # source://RUBY_ROOT/forwardable.rb:226
  def explain(*args, &block); end

  # Find the job with the given JID within this queue.
  #
  # This is a slow, inefficient operation.  Do not use under
  # normal conditions.  Sidekiq Pro contains a faster version.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:294
  def find_job(jid); end

  # source://RUBY_ROOT/forwardable.rb:226
  def increase_busy(*args, &block); end

  # Calculates this queue's latency, the difference in seconds since the oldest
  # job in the queue was enqueued.
  #
  # @return Float
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:257
  def latency; end

  # source://RUBY_ROOT/forwardable.rb:226
  def limit(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def limit=(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def limit_changed?(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def local_busy?(*args, &block); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/queue.rb:19
  def lock; end

  # Returns the value of attribute name.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:236
  def name; end

  # source://RUBY_ROOT/forwardable.rb:226
  def pause(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def pause_for_ms(*args, &block); end

  # Sidekiq Pro overrides this
  #
  # @return [Boolean]
  #
  # source://RUBY_ROOT/forwardable.rb:226
  def paused?(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def probed(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def process_limit(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def process_limit=(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def release(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def remove_locks_except!(*args, &block); end

  # Returns the value of attribute rname.
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/queue.rb:4
  def rname; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:243
  def size; end

  # source://RUBY_ROOT/forwardable.rb:226
  def unblock(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def unblocked(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def unpause(*args, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:298
  def ðŸ’£; end

  class << self
    # Return all known queues within Redis.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/api.rb:232
    def all; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/version.rb:3
Sidekiq::VERSION = T.let(T.unsafe(nil), String)
