# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activemodel` gem.
# Please instead update this file by running `bin/tapioca gem activemodel`.

# source://activemodel-5.2.8.1/lib/active_model/gem_version.rb:3
module ActiveModel
  extend ::ActiveSupport::Autoload

  class << self
    # source://activemodel-5.2.8.1/lib/active_model.rb:69
    def eager_load!; end

    # Returns the version of the currently loaded \Active \Model as a <tt>Gem::Version</tt>
    #
    # source://activemodel-5.2.8.1/lib/active_model/gem_version.rb:5
    def gem_version; end

    # Returns the version of the currently loaded \Active \Model as a <tt>Gem::Version</tt>
    #
    # source://activemodel-5.2.8.1/lib/active_model/version.rb:7
    def version; end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute.rb:6
class ActiveModel::Attribute
  # This method should not be called directly.
  # Use #from_database or #from_user
  #
  # @return [Attribute] a new instance of Attribute
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:33
  def initialize(name, value_before_type_cast, type, original_attribute = T.unsafe(nil)); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:107
  def ==(other); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:99
  def came_from_user?; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:58
  def changed?; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:62
  def changed_in_place?; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:127
  def encode_with(coder); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:107
  def eql?(other); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:66
  def forgetting_assignment; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:103
  def has_been_read?; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:115
  def hash; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:119
  def init_with(coder); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:95
  def initialized?; end

  # Returns the value of attribute name.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:29
  def name; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:46
  def original_value; end

  # Returns the value of attribute type.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:29
  def type; end

  # @raise [NotImplementedError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:91
  def type_cast(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:40
  def value; end

  # Returns the value of attribute value_before_type_cast.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:29
  def value_before_type_cast; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:54
  def value_for_database; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:79
  def with_cast_value(value); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:83
  def with_type(type); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:75
  def with_value_from_database(value); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:70
  def with_value_from_user(value); end

  protected

  # Returns the value of attribute original_attribute.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:137
  def assigned?; end

  # Returns the value of attribute original_attribute.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:137
  def original_attribute; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:140
  def original_value_for_database; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:159
  def _original_value_for_database; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:155
  def changed_from_assignment?; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:149
  def initialize_dup(other); end

  class << self
    # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:8
    def from_database(name, value, type); end

    # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:12
    def from_user(name, value, type, original_attribute = T.unsafe(nil)); end

    # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:20
    def null(name); end

    # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:24
    def uninitialized(name, type); end

    # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:16
    def with_cast_value(name, value, type); end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute.rb:163
class ActiveModel::Attribute::FromDatabase < ::ActiveModel::Attribute
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:168
  def _original_value_for_database; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:164
  def type_cast(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute.rb:173
class ActiveModel::Attribute::FromUser < ::ActiveModel::Attribute
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:178
  def came_from_user?; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:174
  def type_cast(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute.rb:193
class ActiveModel::Attribute::Null < ::ActiveModel::Attribute
  # @return [Null] a new instance of Null
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:194
  def initialize(name); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:198
  def type_cast(*_arg0); end

  # @raise [ActiveModel::MissingAttributeError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:206
  def with_cast_value(value); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:202
  def with_type(type); end

  # @raise [ActiveModel::MissingAttributeError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:206
  def with_value_from_database(value); end

  # @raise [ActiveModel::MissingAttributeError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:206
  def with_value_from_user(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute.rb:213
class ActiveModel::Attribute::Uninitialized < ::ActiveModel::Attribute
  # @return [Uninitialized] a new instance of Uninitialized
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:216
  def initialize(name, type); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:237
  def forgetting_assignment; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:233
  def initialized?; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:226
  def original_value; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:220
  def value; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:230
  def value_for_database; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:241
  def with_type(type); end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute.rb:214
ActiveModel::Attribute::Uninitialized::UNINITIALIZED_ORIGINAL_VALUE = T.let(T.unsafe(nil), Object)

# source://activemodel-5.2.8.1/lib/active_model/attribute/user_provided_default.rb:7
class ActiveModel::Attribute::UserProvidedDefault < ::ActiveModel::Attribute::FromUser
  # @return [UserProvidedDefault] a new instance of UserProvidedDefault
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute/user_provided_default.rb:8
  def initialize(name, value, type, database_default); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute/user_provided_default.rb:25
  def marshal_dump; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute/user_provided_default.rb:36
  def marshal_load(values); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute/user_provided_default.rb:13
  def value_before_type_cast; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute/user_provided_default.rb:21
  def with_type(type); end

  protected

  # Returns the value of attribute user_provided_value.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute/user_provided_default.rb:49
  def user_provided_value; end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute.rb:183
class ActiveModel::Attribute::WithCastValue < ::ActiveModel::Attribute
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:188
  def changed_in_place?; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute.rb:184
  def type_cast(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_assignment.rb:6
module ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection

  # Allows you to set all the attributes by passing in a hash of attributes with
  # keys matching the attribute names.
  #
  # If the passed hash responds to <tt>permitted?</tt> method and the return value
  # of this method is +false+ an <tt>ActiveModel::ForbiddenAttributesError</tt>
  # exception is raised.
  #
  #   class Cat
  #     include ActiveModel::AttributeAssignment
  #     attr_accessor :name, :status
  #   end
  #
  #   cat = Cat.new
  #   cat.assign_attributes(name: "Gorby", status: "yawning")
  #   cat.name # => 'Gorby'
  #   cat.status # => 'yawning'
  #   cat.assign_attributes(status: "sleeping")
  #   cat.name # => 'Gorby'
  #   cat.status # => 'sleeping'
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_assignment.rb:28
  def assign_attributes(new_attributes); end

  # Allows you to set all the attributes by passing in a hash of attributes with
  # keys matching the attribute names.
  #
  # If the passed hash responds to <tt>permitted?</tt> method and the return value
  # of this method is +false+ an <tt>ActiveModel::ForbiddenAttributesError</tt>
  # exception is raised.
  #
  #   class Cat
  #     include ActiveModel::AttributeAssignment
  #     attr_accessor :name, :status
  #   end
  #
  #   cat = Cat.new
  #   cat.assign_attributes(name: "Gorby", status: "yawning")
  #   cat.name # => 'Gorby'
  #   cat.status # => 'yawning'
  #   cat.assign_attributes(status: "sleeping")
  #   cat.name # => 'Gorby'
  #   cat.status # => 'sleeping'
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_assignment.rb:28
  def attributes=(new_attributes); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/attribute_assignment.rb:48
  def _assign_attribute(k, v); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_assignment.rb:42
  def _assign_attributes(attributes); end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:65
module ActiveModel::AttributeMethods
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods

  # +attribute_missing+ is like +method_missing+, but for attributes. When
  # +method_missing+ is called we check to see if there is a matching
  # attribute method. If so, we tell +attribute_missing+ to dispatch the
  # attribute. This method can be overloaded to customize the behavior.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:438
  def attribute_missing(match, *args, &block); end

  # Allows access to the object attributes, which are held in the hash
  # returned by <tt>attributes</tt>, as though they were first-class
  # methods. So a +Person+ class with a +name+ attribute can for example use
  # <tt>Person#name</tt> and <tt>Person#name=</tt> and never directly use
  # the attributes hash -- except for multiple assignments with
  # <tt>ActiveRecord::Base#attributes=</tt>.
  #
  # It's also possible to instantiate related objects, so a <tt>Client</tt>
  # class belonging to the +clients+ table with a +master_id+ foreign key
  # can instantiate master through <tt>Client#master</tt>.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:425
  def method_missing(method, *args, &block); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:446
  def respond_to?(method, include_private_methods = T.unsafe(nil)); end

  # A +Person+ instance with a +name+ attribute can ask
  # <tt>person.respond_to?(:name)</tt>, <tt>person.respond_to?(:name=)</tt>,
  # and <tt>person.respond_to?(:name?)</tt> which will all return +true+.
  def respond_to_without_attributes?(*_arg0); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:474
  def _read_attribute(attr); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:459
  def attribute_method?(attr_name); end

  # Returns a struct representing the matching attribute method.
  # The struct's attributes are prefix, base and suffix.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:465
  def matched_attribute_method(method_name); end

  # @raise [ActiveModel::MissingAttributeError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:470
  def missing_attribute(attr_name, stack); end

  module GeneratedClassMethods
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers?; end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/attributes.rb:102
module ActiveModel::AttributeMethods::AttrNames
  class << self
    # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:103
    def set_name_cache(name, value); end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:69
ActiveModel::AttributeMethods::CALL_COMPILABLE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:76
module ActiveModel::AttributeMethods::ClassMethods
  # Allows you to make aliases for attributes.
  #
  #   class Person
  #     include ActiveModel::AttributeMethods
  #
  #     attr_accessor :name
  #     attribute_method_suffix '_short?'
  #     define_attribute_methods :name
  #
  #     alias_attribute :nickname, :name
  #
  #     private
  #
  #     def attribute_short?(attr)
  #       send(attr).length < 5
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name = 'Bob'
  #   person.name            # => "Bob"
  #   person.nickname        # => "Bob"
  #   person.name_short?     # => true
  #   person.nickname_short? # => true
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:208
  def alias_attribute(new_name, old_name); end

  # Returns the original name for the alias +name+
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:223
  def attribute_alias(name); end

  # Is +new_name+ an alias?
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:218
  def attribute_alias?(new_name); end

  # Declares a method available for all attributes with the given prefix
  # and suffix. Uses +method_missing+ and <tt>respond_to?</tt> to rewrite
  # the method.
  #
  #   #{prefix}#{attr}#{suffix}(*args, &block)
  #
  # to
  #
  #   #{prefix}attribute#{suffix}(#{attr}, *args, &block)
  #
  # An <tt>#{prefix}attribute#{suffix}</tt> instance method must exist and
  # accept at least the +attr+ argument.
  #
  #   class Person
  #     include ActiveModel::AttributeMethods
  #
  #     attr_accessor :name
  #     attribute_method_affix prefix: 'reset_', suffix: '_to_default!'
  #     define_attribute_methods :name
  #
  #     private
  #
  #     def reset_attribute_to_default!(attr)
  #       send("#{attr}=", 'Default Name')
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name                         # => 'Gem'
  #   person.reset_name_to_default!
  #   person.name                         # => 'Default Name'
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:179
  def attribute_method_affix(*affixes); end

  # Declares a method available for all attributes with the given prefix.
  # Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.
  #
  #   #{prefix}#{attr}(*args, &block)
  #
  # to
  #
  #   #{prefix}attribute(#{attr}, *args, &block)
  #
  # An instance method <tt>#{prefix}attribute</tt> must exist and accept
  # at least the +attr+ argument.
  #
  #   class Person
  #     include ActiveModel::AttributeMethods
  #
  #     attr_accessor :name
  #     attribute_method_prefix 'clear_'
  #     define_attribute_methods :name
  #
  #     private
  #
  #     def clear_attribute(attr)
  #       send("#{attr}=", nil)
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name = 'Bob'
  #   person.name          # => "Bob"
  #   person.clear_name
  #   person.name          # => nil
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:108
  def attribute_method_prefix(*prefixes); end

  # Declares a method available for all attributes with the given suffix.
  # Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.
  #
  #   #{attr}#{suffix}(*args, &block)
  #
  # to
  #
  #   attribute#{suffix}(#{attr}, *args, &block)
  #
  # An <tt>attribute#{suffix}</tt> instance method must exist and accept at
  # least the +attr+ argument.
  #
  #   class Person
  #     include ActiveModel::AttributeMethods
  #
  #     attr_accessor :name
  #     attribute_method_suffix '_short?'
  #     define_attribute_methods :name
  #
  #     private
  #
  #     def attribute_short?(attr)
  #       send(attr).length < 5
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name = 'Bob'
  #   person.name          # => "Bob"
  #   person.name_short?   # => true
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:143
  def attribute_method_suffix(*suffixes); end

  # Declares an attribute that should be prefixed and suffixed by
  # <tt>ActiveModel::AttributeMethods</tt>.
  #
  # To use, pass an attribute name (as string or symbol). Be sure to declare
  # +define_attribute_method+ after you define any prefix, suffix or affix
  # method, or they will not hook in.
  #
  #   class Person
  #     include ActiveModel::AttributeMethods
  #
  #     attr_accessor :name
  #     attribute_method_suffix '_short?'
  #
  #     # Call to define_attribute_method must appear after the
  #     # attribute_method_prefix, attribute_method_suffix or
  #     # attribute_method_affix declarations.
  #     define_attribute_method :name
  #
  #     private
  #
  #     def attribute_short?(attr)
  #       send(attr).length < 5
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name = 'Bob'
  #   person.name        # => "Bob"
  #   person.name_short? # => true
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:284
  def define_attribute_method(attr_name); end

  # Declares the attributes that should be prefixed and suffixed by
  # <tt>ActiveModel::AttributeMethods</tt>.
  #
  # To use, pass attribute names (as strings or symbols). Be sure to declare
  # +define_attribute_methods+ after you define any prefix, suffix or affix
  # methods, or they will not hook in.
  #
  #   class Person
  #     include ActiveModel::AttributeMethods
  #
  #     attr_accessor :name, :age, :address
  #     attribute_method_prefix 'clear_'
  #
  #     # Call to define_attribute_methods must appear after the
  #     # attribute_method_prefix, attribute_method_suffix or
  #     # attribute_method_affix declarations.
  #     define_attribute_methods :name, :age, :address
  #
  #     private
  #
  #     def clear_attribute(attr)
  #       send("#{attr}=", nil)
  #     end
  #   end
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:251
  def define_attribute_methods(*attr_names); end

  # Removes all the previously dynamically defined methods from the class.
  #
  #   class Person
  #     include ActiveModel::AttributeMethods
  #
  #     attr_accessor :name
  #     attribute_method_suffix '_short?'
  #     define_attribute_method :name
  #
  #     private
  #
  #     def attribute_short?(attr)
  #       send(attr).length < 5
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name = 'Bob'
  #   person.name_short? # => true
  #
  #   Person.undefine_attribute_methods
  #
  #   person.name_short? # => NoMethodError
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:324
  def undefine_attribute_methods; end

  private

  # The methods +method_missing+ and +respond_to?+ of this module are
  # invoked often in a typical rails, both of which invoke the method
  # +matched_attribute_method+. The latter method iterates through an
  # array doing regular expression matches, which results in a lot of
  # object creations. Most of the time it returns a +nil+ match. As the
  # match result is always the same given a +method_name+, this cache is
  # used to alleviate the GC, which ultimately also speeds up the app
  # significantly (in our case our test suite finishes 10% faster with
  # this cache).
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:349
  def attribute_method_matchers_cache; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:353
  def attribute_method_matchers_matching(method_name); end

  # Define a method `name` in `mod` that dispatches to `send`
  # using the given `extra` args. This falls back on `define_method`
  # and `send` if the given names cannot be compiled.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:365
  def define_proxy_call(include_private, mod, name, send, *extra); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:332
  def generated_attribute_methods; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:336
  def instance_method_already_implemented?(method_name); end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:387
class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher
  # @return [AttributeMethodMatcher] a new instance of AttributeMethodMatcher
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:392
  def initialize(options = T.unsafe(nil)); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:399
  def match(method_name); end

  # Returns the value of attribute method_missing_target.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:388
  def method_missing_target; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:405
  def method_name(attr_name); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:409
  def plain?; end

  # Returns the value of attribute prefix.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:388
  def prefix; end

  # Returns the value of attribute suffix.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:388
  def suffix; end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:390
class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher::AttributeMethodMatch < ::Struct
  # Returns the value of attribute attr_name
  #
  # @return [Object] the current value of attr_name
  def attr_name; end

  # Sets the attribute attr_name
  #
  # @param value [Object] the value to set the attribute attr_name to.
  # @return [Object] the newly set value
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:390
  def attr_name=(_); end

  # Returns the value of attribute method_name
  #
  # @return [Object] the current value of method_name
  def method_name; end

  # Sets the attribute method_name
  #
  # @param value [Object] the value to set the attribute method_name to.
  # @return [Object] the newly set value
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:390
  def method_name=(_); end

  # Returns the value of attribute target
  #
  # @return [Object] the current value of target
  def target; end

  # Sets the attribute target
  #
  # @param value [Object] the value to set the attribute target to.
  # @return [Object] the newly set value
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:390
  def target=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:68
ActiveModel::AttributeMethods::NAME_COMPILABLE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:6
class ActiveModel::AttributeMutationTracker
  # @return [AttributeMutationTracker] a new instance of AttributeMutationTracker
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:9
  def initialize(attributes); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:42
  def any_changes?; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:35
  def change_to_attribute(attr_name); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:46
  def changed?(attr_name, from: T.unsafe(nil), to: T.unsafe(nil)); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:14
  def changed_attribute_names; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:54
  def changed_in_place?(attr_name); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:18
  def changed_values; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:26
  def changes; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:68
  def force_change(attr_name); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:58
  def forget_change(attr_name); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:64
  def original_value(attr_name); end

  protected

  # Returns the value of attribute attributes.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:76
  def attributes; end

  # Returns the value of attribute forced_changes.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:76
  def forced_changes; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:80
  def attr_names; end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:7
ActiveModel::AttributeMutationTracker::OPTION_NOT_GIVEN = T.let(T.unsafe(nil), Object)

# source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:6
class ActiveModel::AttributeSet
  # @return [AttributeSet] a new instance of AttributeSet
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:11
  def initialize(attributes); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:100
  def ==(other); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:15
  def [](name); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:19
  def []=(name, value); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:91
  def accessed; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:69
  def deep_dup; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:9
  def each_value(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:9
  def except(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:9
  def fetch(*args, &block); end

  # This form is significantly faster on JRuby, and this is one of our biggest hotspots.
  # https://github.com/jruby/jruby/pull/2562
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:47
  def fetch_value(name); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:64
  def freeze; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:32
  def key?(name); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:36
  def keys; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:95
  def map(&block); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:85
  def reset(key); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:27
  def to_h; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:27
  def to_hash; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:23
  def values_before_type_cast; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:60
  def write_cast_value(name, value); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:52
  def write_from_database(name, value); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:56
  def write_from_user(name, value); end

  protected

  # Returns the value of attribute attributes.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:106
  def attributes; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:80
  def initialize_clone(_); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:75
  def initialize_dup(_); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set.rb:110
  def initialized_attributes; end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:7
class ActiveModel::AttributeSet::Builder
  # @return [Builder] a new instance of Builder
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:10
  def initialize(types, default_attributes = T.unsafe(nil)); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:15
  def build_from_database(values = T.unsafe(nil), additional_types = T.unsafe(nil)); end

  # Returns the value of attribute default_attributes.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:8
  def default_attributes; end

  # Returns the value of attribute types.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:8
  def types; end
end

# Attempts to do more intelligent YAML dumping of an
# ActiveModel::AttributeSet to reduce the size of the resulting string
#
# source://activemodel-5.2.8.1/lib/active_model/attribute_set/yaml_encoder.rb:7
class ActiveModel::AttributeSet::YAMLEncoder
  # @return [YAMLEncoder] a new instance of YAMLEncoder
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/yaml_encoder.rb:8
  def initialize(default_types); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/yaml_encoder.rb:22
  def decode(coder); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/yaml_encoder.rb:12
  def encode(attribute_set, coder); end

  protected

  # Returns the value of attribute default_types.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/yaml_encoder.rb:38
  def default_types; end
end

# source://activemodel-5.2.8.1/lib/active_model/attributes.rb:7
module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveModel::AttributeMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods
  mixes_in_class_methods ::ActiveModel::Attributes::ClassMethods

  # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:64
  def initialize(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:69
  def attributes; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:86
  def attribute(attr_name); end

  # Handle *= for method_missing.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:96
  def attribute=(attribute_name, value); end

  # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:75
  def write_attribute(attr_name, value); end

  module GeneratedClassMethods
    def _default_attributes; end
    def _default_attributes=(value); end
    def _default_attributes?; end
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
    def attribute_types; end
    def attribute_types=(value); end
    def attribute_types?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers?; end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/attributes.rb:18
module ActiveModel::Attributes::ClassMethods
  # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:19
  def attribute(name, type = T.unsafe(nil), **options); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:48
  def define_default_attribute(name, value, type); end

  # source://activemodel-5.2.8.1/lib/active_model/attributes.rb:31
  def define_method_attribute=(name); end
end

# source://activemodel-5.2.8.1/lib/active_model/attributes.rb:45
ActiveModel::Attributes::ClassMethods::NO_DEFAULT_PROVIDED = T.let(T.unsafe(nil), Object)

# +BlockValidator+ is a special +EachValidator+ which receives a block on initialization
# and call this block for each attribute being validated. +validates_each+ uses this validator.
#
# source://activemodel-5.2.8.1/lib/active_model/validator.rb:171
class ActiveModel::BlockValidator < ::ActiveModel::EachValidator
  # @return [BlockValidator] a new instance of BlockValidator
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:172
  def initialize(options, &block); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:179
  def validate_each(record, attribute, value); end
end

# == Active \Model \Callbacks
#
# Provides an interface for any class to have Active Record like callbacks.
#
# Like the Active Record methods, the callback chain is aborted as soon as
# one of the methods throws +:abort+.
#
# First, extend ActiveModel::Callbacks from the class you are creating:
#
#   class MyModel
#     extend ActiveModel::Callbacks
#   end
#
# Then define a list of methods that you want callbacks attached to:
#
#   define_model_callbacks :create, :update
#
# This will provide all three standard callbacks (before, around and after)
# for both the <tt>:create</tt> and <tt>:update</tt> methods. To implement,
# you need to wrap the methods you want callbacks on in a block so that the
# callbacks get a chance to fire:
#
#   def create
#     run_callbacks :create do
#       # Your create action methods here
#     end
#   end
#
# Then in your class, you can use the +before_create+, +after_create+ and
# +around_create+ methods, just as you would in an Active Record model.
#
#   before_create :action_before_create
#
#   def action_before_create
#     # Your code here
#   end
#
# When defining an around callback remember to yield to the block, otherwise
# it won't be executed:
#
#  around_create :log_status
#
#  def log_status
#    puts 'going to call the block...'
#    yield
#    puts 'block successfully called.'
#  end
#
# You can choose to have only specific callbacks by passing a hash to the
# +define_model_callbacks+ method.
#
#   define_model_callbacks :create, only: [:after, :before]
#
# Would only create the +after_create+ and +before_create+ callback methods in
# your class.
#
# NOTE: Calling the same callback multiple times will overwrite previous callback definitions.
#
# source://activemodel-5.2.8.1/lib/active_model/callbacks.rb:64
module ActiveModel::Callbacks
  # define_model_callbacks accepts the same options +define_callbacks+ does,
  # in case you want to overwrite a default. Besides that, it also accepts an
  # <tt>:only</tt> option, where you can choose if you want all types (before,
  # around or after) or just some.
  #
  #   define_model_callbacks :initializer, only: :after
  #
  # Note, the <tt>only: <type></tt> hash will apply to all callbacks defined
  # on that method call. To get around this you can call the define_model_callbacks
  # method as many times as you need.
  #
  #   define_model_callbacks :create,  only: :after
  #   define_model_callbacks :update,  only: :before
  #   define_model_callbacks :destroy, only: :around
  #
  # Would create +after_create+, +before_update+ and +around_destroy+ methods
  # only.
  #
  # You can pass in a class to before_<type>, after_<type> and around_<type>,
  # in which case the callback will call that class's <action>_<type> method
  # passing the object that the callback is being called on.
  #
  #   class MyModel
  #     extend ActiveModel::Callbacks
  #     define_model_callbacks :create
  #
  #     before_create AnotherClass
  #   end
  #
  #   class AnotherClass
  #     def self.before_create( obj )
  #       # obj is the MyModel instance that the callback is being called on
  #     end
  #   end
  #
  # NOTE: +method_name+ passed to define_model_callbacks must not end with
  # <tt>!</tt>, <tt>?</tt> or <tt>=</tt>.
  #
  # source://activemodel-5.2.8.1/lib/active_model/callbacks.rb:108
  def define_model_callbacks(*callbacks); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/callbacks.rb:141
  def _define_after_model_callback(klass, callback); end

  # source://activemodel-5.2.8.1/lib/active_model/callbacks.rb:135
  def _define_around_model_callback(klass, callback); end

  # source://activemodel-5.2.8.1/lib/active_model/callbacks.rb:129
  def _define_before_model_callback(klass, callback); end

  class << self
    # source://activemodel-5.2.8.1/lib/active_model/callbacks.rb:65
    def extended(base); end
  end
end

# == Active \Model \Conversion
#
# Handles default conversions: to_model, to_key, to_param, and to_partial_path.
#
# Let's take for example this non-persisted object.
#
#   class ContactMessage
#     include ActiveModel::Conversion
#
#     # ContactMessage are never persisted in the DB
#     def persisted?
#       false
#     end
#   end
#
#   cm = ContactMessage.new
#   cm.to_model == cm  # => true
#   cm.to_key          # => nil
#   cm.to_param        # => nil
#   cm.to_partial_path # => "contact_messages/contact_message"
#
# source://activemodel-5.2.8.1/lib/active_model/conversion.rb:24
module ActiveModel::Conversion
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveModel::Conversion::ClassMethods

  # Returns an Array of all key attributes if any of the attributes is set, whether or not
  # the object is persisted. Returns +nil+ if there are no key attributes.
  #
  #   class Person
  #     include ActiveModel::Conversion
  #     attr_accessor :id
  #
  #     def initialize(id)
  #       @id = id
  #     end
  #   end
  #
  #   person = Person.new(1)
  #   person.to_key # => [1]
  #
  # source://activemodel-5.2.8.1/lib/active_model/conversion.rb:59
  def to_key; end

  # If your object is already designed to implement all of the \Active \Model
  # you can use the default <tt>:to_model</tt> implementation, which simply
  # returns +self+.
  #
  #   class Person
  #     include ActiveModel::Conversion
  #   end
  #
  #   person = Person.new
  #   person.to_model == person # => true
  #
  # If your model does not act like an \Active \Model object, then you should
  # define <tt>:to_model</tt> yourself returning a proxy object that wraps
  # your object with \Active \Model compliant methods.
  #
  # source://activemodel-5.2.8.1/lib/active_model/conversion.rb:41
  def to_model; end

  # Returns a +string+ representing the object's key suitable for use in URLs,
  # or +nil+ if <tt>persisted?</tt> is +false+.
  #
  #   class Person
  #     include ActiveModel::Conversion
  #     attr_accessor :id
  #
  #     def initialize(id)
  #       @id = id
  #     end
  #
  #     def persisted?
  #       true
  #     end
  #   end
  #
  #   person = Person.new(1)
  #   person.to_param # => "1"
  #
  # source://activemodel-5.2.8.1/lib/active_model/conversion.rb:82
  def to_param; end

  # Returns a +string+ identifying the path associated with the object.
  # ActionPack uses this to find a suitable partial to represent the object.
  #
  #   class Person
  #     include ActiveModel::Conversion
  #   end
  #
  #   person = Person.new
  #   person.to_partial_path # => "people/person"
  #
  # source://activemodel-5.2.8.1/lib/active_model/conversion.rb:95
  def to_partial_path; end
end

# source://activemodel-5.2.8.1/lib/active_model/conversion.rb:99
module ActiveModel::Conversion::ClassMethods
  # Provide a class level cache for #to_partial_path. This is an
  # internal method and should not be accessed directly.
  #
  # source://activemodel-5.2.8.1/lib/active_model/conversion.rb:102
  def _to_partial_path; end
end

# == Active \Model \Dirty
#
# Provides a way to track changes in your object in the same way as
# Active Record does.
#
# The requirements for implementing ActiveModel::Dirty are:
#
# * <tt>include ActiveModel::Dirty</tt> in your object.
# * Call <tt>define_attribute_methods</tt> passing each method you want to
#   track.
# * Call <tt>[attr_name]_will_change!</tt> before each change to the tracked
#   attribute.
# * Call <tt>changes_applied</tt> after the changes are persisted.
# * Call <tt>clear_changes_information</tt> when you want to reset the changes
#   information.
# * Call <tt>restore_attributes</tt> when you want to restore previous data.
#
# A minimal implementation could be:
#
#   class Person
#     include ActiveModel::Dirty
#
#     define_attribute_methods :name
#
#     def initialize
#       @name = nil
#     end
#
#     def name
#       @name
#     end
#
#     def name=(val)
#       name_will_change! unless val == @name
#       @name = val
#     end
#
#     def save
#       # do persistence work
#
#       changes_applied
#     end
#
#     def reload!
#       # get the values from the persistence layer
#
#       clear_changes_information
#     end
#
#     def rollback!
#       restore_attributes
#     end
#   end
#
# A newly instantiated +Person+ object is unchanged:
#
#   person = Person.new
#   person.changed? # => false
#
# Change the name:
#
#   person.name = 'Bob'
#   person.changed?       # => true
#   person.name_changed?  # => true
#   person.name_changed?(from: nil, to: "Bob") # => true
#   person.name_was       # => nil
#   person.name_change    # => [nil, "Bob"]
#   person.name = 'Bill'
#   person.name_change    # => [nil, "Bill"]
#
# Save the changes:
#
#   person.save
#   person.changed?      # => false
#   person.name_changed? # => false
#
# Reset the changes:
#
#   person.previous_changes         # => {"name" => [nil, "Bill"]}
#   person.name_previously_changed? # => true
#   person.name_previous_change     # => [nil, "Bill"]
#   person.reload!
#   person.previous_changes         # => {}
#
# Rollback the changes:
#
#   person.name = "Uncle Bob"
#   person.rollback!
#   person.name          # => "Bill"
#   person.name_changed? # => false
#
# Assigning the same value leaves the attribute unchanged:
#
#   person.name = 'Bill'
#   person.name_changed? # => false
#   person.name_change   # => nil
#
# Which attributes have changed?
#
#   person.name = 'Bob'
#   person.changed # => ["name"]
#   person.changes # => {"name" => ["Bill", "Bob"]}
#
# If an attribute is modified in-place then make use of
# <tt>[attribute_name]_will_change!</tt> to mark that the attribute is changing.
# Otherwise \Active \Model can't track changes to in-place attributes. Note
# that Active Record can detect in-place modifications automatically. You do
# not need to call <tt>[attribute_name]_will_change!</tt> on Active Record models.
#
#   person.name_will_change!
#   person.name_change # => ["Bill", "Bill"]
#   person.name << 'y'
#   person.name_change # => ["Bill", "Billy"]
#
# source://activemodel-5.2.8.1/lib/active_model/dirty.rb:121
module ActiveModel::Dirty
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveModel::AttributeMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods

  # Handles <tt>*_changed?</tt> for +method_missing+.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:175
  def attribute_changed?(attr, from: T.unsafe(nil), to: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:251
  def attribute_changed_in_place?(attr_name); end

  # Handles <tt>*_previously_changed?</tt> for +method_missing+.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:187
  def attribute_previously_changed?(attr); end

  # Handles <tt>*_was</tt> for +method_missing+.
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:182
  def attribute_was(attr); end

  # Returns an array with the name of the attributes with unsaved changes.
  #
  #   person.changed # => []
  #   person.name = 'bob'
  #   person.changed # => ["name"]
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:170
  def changed; end

  # Returns +true+ if any of the attributes have unsaved changes, +false+ otherwise.
  #
  #   person.changed? # => false
  #   person.name = 'bob'
  #   person.changed? # => true
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:161
  def changed?; end

  # Returns a hash of the attributes with unsaved changes indicating their original
  # values like <tt>attr => original value</tt>.
  #
  #   person.name # => "bob"
  #   person.name = 'robert'
  #   person.changed_attributes # => {"name" => "bob"}
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:218
  def changed_attributes; end

  # Returns a hash of changed attributes indicating their original
  # and new values like <tt>attr => [original value, new value]</tt>.
  #
  #   person.changes # => {}
  #   person.name = 'bob'
  #   person.changes # => { "name" => ["bill", "bob"] }
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:234
  def changes; end

  # Clears dirty data and moves +changes+ to +previously_changed+ and
  # +mutations_from_database+ to +mutations_before_last_save+ respectively.
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:146
  def changes_applied; end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:205
  def clear_attribute_changes(attr_names); end

  # Clears all dirty data: current changes and previous changes.
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:197
  def clear_changes_information; end

  # Returns a hash of attributes that were changed before the model was saved.
  #
  #   person.name # => "bob"
  #   person.name = 'robert'
  #   person.save
  #   person.previous_changes # => {"name" => ["bob", "robert"]}
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:246
  def previous_changes; end

  # Restore all previous data of the provided attributes.
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:192
  def restore_attributes(attributes = T.unsafe(nil)); end

  private

  # Handles <tt>*_change</tt> for +method_missing+.
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:303
  def attribute_change(attr); end

  # Returns +true+ if attr_name is changed, +false+ otherwise.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:291
  def attribute_changed_by_setter?(attr_name); end

  # Handles <tt>*_previous_change</tt> for +method_missing+.
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:308
  def attribute_previous_change(attr); end

  # Handles <tt>*_will_change!</tt> for +method_missing+.
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:313
  def attribute_will_change!(attr); end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:334
  def attributes_changed_by_setter; end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:279
  def cache_changed_attributes; end

  # Returns +true+ if attr_name is changed, +false+ otherwise.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:291
  def changes_include?(attr_name); end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:256
  def clear_attribute_change(attr_name); end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:286
  def clear_changed_attributes_cache; end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:271
  def forget_attribute_assignments; end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:134
  def initialize_dup(other); end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:275
  def mutations_before_last_save; end

  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:260
  def mutations_from_database; end

  # Returns +true+ if attr_name were changed before the model was saved,
  # +false+ otherwise.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:298
  def previous_changes_include?(attr_name); end

  # Handles <tt>restore_*!</tt> for +method_missing+.
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:327
  def restore_attribute!(attr); end

  # Force an attribute to have a particular "before" value
  #
  # source://activemodel-5.2.8.1/lib/active_model/dirty.rb:339
  def set_attribute_was(attr, old_value); end

  module GeneratedClassMethods
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers?; end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/dirty.rb:125
ActiveModel::Dirty::OPTION_NOT_GIVEN = T.let(T.unsafe(nil), Object)

# +EachValidator+ is a validator which iterates through the attributes given
# in the options hash invoking the <tt>validate_each</tt> method passing in the
# record, attribute and value.
#
# All \Active \Model validations are built on top of this validator.
#
# source://activemodel-5.2.8.1/lib/active_model/validator.rb:132
class ActiveModel::EachValidator < ::ActiveModel::Validator
  # Returns a new validator instance. All options will be available via the
  # +options+ reader, however the <tt>:attributes</tt> option will be removed
  # and instead be made available through the +attributes+ reader.
  #
  # @raise [ArgumentError]
  # @return [EachValidator] a new instance of EachValidator
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:138
  def initialize(options); end

  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:133
  def attributes; end

  # Hook method that gets called by the initializer allowing verification
  # that the arguments supplied are valid. You could for example raise an
  # +ArgumentError+ when invalid options are supplied.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:165
  def check_validity!; end

  # Performs validation on the supplied record. By default this will call
  # +validate_each+ to determine validity therefore subclasses should
  # override +validate_each+ with validation logic.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:148
  def validate(record); end

  # Override this method in subclasses with the validation logic, adding
  # errors to the records +errors+ array where necessary.
  #
  # @raise [NotImplementedError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:158
  def validate_each(record, attribute, value); end
end

# == Active \Model \Errors
#
# Provides a modified +Hash+ that you can include in your object
# for handling error messages and interacting with Action View helpers.
#
# A minimal implementation could be:
#
#   class Person
#     # Required dependency for ActiveModel::Errors
#     extend ActiveModel::Naming
#
#     def initialize
#       @errors = ActiveModel::Errors.new(self)
#     end
#
#     attr_accessor :name
#     attr_reader   :errors
#
#     def validate!
#       errors.add(:name, :blank, message: "cannot be nil") if name.nil?
#     end
#
#     # The following methods are needed to be minimally implemented
#
#     def read_attribute_for_validation(attr)
#       send(attr)
#     end
#
#     def self.human_attribute_name(attr, options = {})
#       attr
#     end
#
#     def self.lookup_ancestors
#       [self]
#     end
#   end
#
# The last three methods are required in your object for +Errors+ to be
# able to generate error messages correctly and also handle multiple
# languages. Of course, if you extend your object with <tt>ActiveModel::Translation</tt>
# you will not need to implement the last two. Likewise, using
# <tt>ActiveModel::Validations</tt> will handle the validation related methods
# for you.
#
# The above allows you to do:
#
#   person = Person.new
#   person.validate!            # => ["cannot be nil"]
#   person.errors.full_messages # => ["name cannot be nil"]
#   # etc..
#
# source://activemodel-5.2.8.1/lib/active_model/errors.rb:59
class ActiveModel::Errors
  include ::Enumerable

  # Pass in the instance of the object that is using the errors object.
  #
  #   class Person
  #     def initialize
  #       @errors = ActiveModel::Errors.new(self)
  #     end
  #   end
  #
  # @return [Errors] a new instance of Errors
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:74
  def initialize(base); end

  # When passed a symbol or a name of a method, returns an array of errors
  # for the method.
  #
  #   person.errors[:name]  # => ["cannot be nil"]
  #   person.errors['name'] # => ["cannot be nil"]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:149
  def [](attribute); end

  # Adds +message+ to the error messages and used validator type to +details+ on +attribute+.
  # More than one error can be added to the same +attribute+.
  # If no +message+ is supplied, <tt>:invalid</tt> is assumed.
  #
  #   person.errors.add(:name)
  #   # => ["is invalid"]
  #   person.errors.add(:name, :not_implemented, message: "must be implemented")
  #   # => ["is invalid", "must be implemented"]
  #
  #   person.errors.messages
  #   # => {:name=>["is invalid", "must be implemented"]}
  #
  #   person.errors.details
  #   # => {:name=>[{error: :not_implemented}, {error: :invalid}]}
  #
  # If +message+ is a symbol, it will be translated using the appropriate
  # scope (see +generate_message+).
  #
  # If +message+ is a proc, it will be called, allowing for things like
  # <tt>Time.now</tt> to be used within an error.
  #
  # If the <tt>:strict</tt> option is set to +true+, it will raise
  # ActiveModel::StrictValidationFailed instead of adding the error.
  # <tt>:strict</tt> option can also be set to any other exception.
  #
  #   person.errors.add(:name, :invalid, strict: true)
  #   # => ActiveModel::StrictValidationFailed: Name is invalid
  #   person.errors.add(:name, :invalid, strict: NameIsInvalid)
  #   # => NameIsInvalid: Name is invalid
  #
  #   person.errors.messages # => {}
  #
  # +attribute+ should be set to <tt>:base</tt> if the error is not
  # directly associated with a single attribute.
  #
  #   person.errors.add(:base, :name_or_email_blank,
  #     message: "either name or email must be present")
  #   person.errors.messages
  #   # => {:base=>["either name or email must be present"]}
  #   person.errors.details
  #   # => {:base=>[{error: :name_or_email_blank}]}
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:295
  def add(attribute, message = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns +true+ if an error on the attribute with the given message is
  # present, or +false+ otherwise. +message+ is treated the same as for +add+.
  #
  #   person.errors.add :name, :blank
  #   person.errors.added? :name, :blank           # => true
  #   person.errors.added? :name, "can't be blank" # => true
  #
  # If the error message requires an option, then it returns +true+ with
  # the correct option, or +false+ with an incorrect or missing option.
  #
  #  person.errors.add :name, :too_long, { count: 25 }
  #  person.errors.added? :name, :too_long, count: 25                     # => true
  #  person.errors.added? :name, "is too long (maximum is 25 characters)" # => true
  #  person.errors.added? :name, :too_long, count: 24                     # => false
  #  person.errors.added? :name, :too_long                                # => false
  #  person.errors.added? :name, "is too long"                            # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:324
  def added?(attribute, message = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns a Hash that can be used as the JSON representation for this
  # object. You can pass the <tt>:full_messages</tt> option. This determines
  # if the json object should contain full messages or not (false by default).
  #
  #   person.errors.as_json                      # => {:name=>["cannot be nil"]}
  #   person.errors.as_json(full_messages: true) # => {:name=>["name cannot be nil"]}
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:235
  def as_json(options = T.unsafe(nil)); end

  # Returns +true+ if no errors are found, +false+ otherwise.
  # If the error message is a string it can be empty.
  #
  #   person.errors.full_messages # => ["name cannot be nil"]
  #   person.errors.empty?        # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:209
  def blank?; end

  # Clear the error messages.
  #
  #   person.errors.full_messages # => ["name cannot be nil"]
  #   person.errors.clear
  #   person.errors.full_messages # => []
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:115
  def clear; end

  # Copies the errors from <tt>other</tt>.
  #
  # other - The ActiveModel::Errors instance.
  #
  # Examples
  #
  #   person.errors.copy!(other)
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:93
  def copy!(other); end

  # Returns the number of error messages.
  #
  #   person.errors.add(:name, :blank, message: "can't be blank")
  #   person.errors.size # => 1
  #   person.errors.add(:name, :not_specified, message: "must be specified")
  #   person.errors.size # => 2
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:179
  def count; end

  # Delete messages for +key+. Returns the deleted messages.
  #
  #   person.errors[:name]        # => ["cannot be nil"]
  #   person.errors.delete(:name) # => ["cannot be nil"]
  #   person.errors[:name]        # => []
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:138
  def delete(key); end

  # Returns the value of attribute details.
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:65
  def details; end

  # Iterates through each error key, value pair in the error messages hash.
  # Yields the attribute and the error for that attribute. If the attribute
  # has more than one error message, yields once for each error message.
  #
  #   person.errors.add(:name, :blank, message: "can't be blank")
  #   person.errors.each do |attribute, error|
  #     # Will yield :name and "can't be blank"
  #   end
  #
  #   person.errors.add(:name, :not_specified, message: "must be specified")
  #   person.errors.each do |attribute, error|
  #     # Will yield :name and "can't be blank"
  #     # then yield :name and "must be specified"
  #   end
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:167
  def each; end

  # Returns +true+ if no errors are found, +false+ otherwise.
  # If the error message is a string it can be empty.
  #
  #   person.errors.full_messages # => ["name cannot be nil"]
  #   person.errors.empty?        # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:209
  def empty?; end

  # Returns a full message for a given attribute.
  #
  #   person.errors.full_message(:name, 'is invalid') # => "Name is invalid"
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:367
  def full_message(attribute, message); end

  # Returns all the full error messages in an array.
  #
  #   class Person
  #     validates_presence_of :name, :address, :email
  #     validates_length_of :name, in: 5..30
  #   end
  #
  #   person = Person.create(address: '123 First St.')
  #   person.errors.full_messages
  #   # => ["Name is too short (minimum is 5 characters)", "Name can't be blank", "Email can't be blank"]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:344
  def full_messages; end

  # Returns all the full error messages for a given attribute in an array.
  #
  #   class Person
  #     validates_presence_of :name, :email
  #     validates_length_of :name, in: 5..30
  #   end
  #
  #   person = Person.create()
  #   person.errors.full_messages_for(:name)
  #   # => ["Name is too short (minimum is 5 characters)", "Name can't be blank"]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:359
  def full_messages_for(attribute); end

  # Translates an error message in its default scope
  # (<tt>activemodel.errors.messages</tt>).
  #
  # Error messages are first looked up in <tt>activemodel.errors.models.MODEL.attributes.ATTRIBUTE.MESSAGE</tt>,
  # if it's not there, it's looked up in <tt>activemodel.errors.models.MODEL.MESSAGE</tt> and if
  # that is not there also, it returns the translation of the default message
  # (e.g. <tt>activemodel.errors.messages.MESSAGE</tt>). The translated model
  # name, translated attribute name and the value are available for
  # interpolation.
  #
  # When using inheritance in your models, it will check all the inherited
  # models too, but only if the model itself hasn't been found. Say you have
  # <tt>class Admin < User; end</tt> and you wanted the translation for
  # the <tt>:blank</tt> error message for the <tt>title</tt> attribute,
  # it looks for these translations:
  #
  # * <tt>activemodel.errors.models.admin.attributes.title.blank</tt>
  # * <tt>activemodel.errors.models.admin.blank</tt>
  # * <tt>activemodel.errors.models.user.attributes.title.blank</tt>
  # * <tt>activemodel.errors.models.user.blank</tt>
  # * any default you provided through the +options+ hash (in the <tt>activemodel.errors</tt> scope)
  # * <tt>activemodel.errors.messages.blank</tt>
  # * <tt>errors.attributes.title.blank</tt>
  # * <tt>errors.messages.blank</tt>
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:401
  def generate_message(attribute, type = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns +true+ if the error messages include an error for the given key
  # +attribute+, +false+ otherwise.
  #
  #   person.errors.messages        # => {:name=>["cannot be nil"]}
  #   person.errors.include?(:name) # => true
  #   person.errors.include?(:age)  # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:126
  def has_key?(attribute); end

  # Returns +true+ if the error messages include an error for the given key
  # +attribute+, +false+ otherwise.
  #
  #   person.errors.messages        # => {:name=>["cannot be nil"]}
  #   person.errors.include?(:name) # => true
  #   person.errors.include?(:age)  # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:126
  def include?(attribute); end

  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:443
  def init_with(coder); end

  # Returns +true+ if the error messages include an error for the given key
  # +attribute+, +false+ otherwise.
  #
  #   person.errors.messages        # => {:name=>["cannot be nil"]}
  #   person.errors.include?(:name) # => true
  #   person.errors.include?(:age)  # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:126
  def key?(attribute); end

  # Returns all message keys.
  #
  #   person.errors.messages # => {:name=>["cannot be nil", "must be specified"]}
  #   person.errors.keys     # => [:name]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:198
  def keys; end

  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:433
  def marshal_dump; end

  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:437
  def marshal_load(array); end

  # Merges the errors from <tt>other</tt>.
  #
  # other - The ActiveModel::Errors instance.
  #
  # Examples
  #
  #   person.errors.merge!(other)
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:105
  def merge!(other); end

  # Returns the value of attribute messages.
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:65
  def messages; end

  # Returns the number of error messages.
  #
  #   person.errors.add(:name, :blank, message: "can't be blank")
  #   person.errors.size # => 1
  #   person.errors.add(:name, :not_specified, message: "must be specified")
  #   person.errors.size # => 2
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:179
  def size; end

  # Returns all the full error messages in an array.
  #
  #   class Person
  #     validates_presence_of :name, :address, :email
  #     validates_length_of :name, in: 5..30
  #   end
  #
  #   person = Person.create(address: '123 First St.')
  #   person.errors.full_messages
  #   # => ["Name is too short (minimum is 5 characters)", "Name can't be blank", "Email can't be blank"]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:344
  def to_a; end

  # Returns a Hash of attributes with their error messages. If +full_messages+
  # is +true+, it will contain full messages (see +full_message+).
  #
  #   person.errors.to_hash       # => {:name=>["cannot be nil"]}
  #   person.errors.to_hash(true) # => {:name=>["name cannot be nil"]}
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:244
  def to_hash(full_messages = T.unsafe(nil)); end

  # Returns an xml formatted representation of the Errors hash.
  #
  #   person.errors.add(:name, :blank, message: "can't be blank")
  #   person.errors.add(:name, :not_specified, message: "must be specified")
  #   person.errors.to_xml
  #   # =>
  #   #  <?xml version=\"1.0\" encoding=\"UTF-8\"?>
  #   #  <errors>
  #   #    <error>name can't be blank</error>
  #   #    <error>name must be specified</error>
  #   #  </errors>
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:225
  def to_xml(options = T.unsafe(nil)); end

  # Returns all message values.
  #
  #   person.errors.messages # => {:name=>["cannot be nil", "must be specified"]}
  #   person.errors.values   # => [["cannot be nil", "must be specified"]]
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:188
  def values; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:470
  def apply_default_array(hash); end

  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:80
  def initialize_dup(other); end

  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:460
  def normalize_detail(message, options); end

  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:451
  def normalize_message(attribute, message, options); end

  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:464
  def without_default_proc(hash); end
end

# source://activemodel-5.2.8.1/lib/active_model/errors.rb:62
ActiveModel::Errors::CALLBACKS_OPTIONS = T.let(T.unsafe(nil), Array)

# source://activemodel-5.2.8.1/lib/active_model/errors.rb:63
ActiveModel::Errors::MESSAGE_OPTIONS = T.let(T.unsafe(nil), Array)

# Raised when forbidden attributes are used for mass assignment.
#
#   class Person < ActiveRecord::Base
#   end
#
#   params = ActionController::Parameters.new(name: 'Bob')
#   Person.new(params)
#   # => ActiveModel::ForbiddenAttributesError
#
#   params.permit!
#   Person.new(params)
#   # => #<Person id: nil, name: "Bob">
#
# source://activemodel-5.2.8.1/lib/active_model/forbidden_attributes_protection.rb:16
class ActiveModel::ForbiddenAttributesError < ::StandardError; end

# source://activemodel-5.2.8.1/lib/active_model/forbidden_attributes_protection.rb:19
module ActiveModel::ForbiddenAttributesProtection
  private

  # source://activemodel-5.2.8.1/lib/active_model/forbidden_attributes_protection.rb:21
  def sanitize_for_mass_assignment(attributes); end

  # source://activemodel-5.2.8.1/lib/active_model/forbidden_attributes_protection.rb:21
  def sanitize_forbidden_attributes(attributes); end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:22
class ActiveModel::LazyAttributeHash
  # @return [LazyAttributeHash] a new instance of LazyAttributeHash
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:25
  def initialize(types, values, additional_types, default_attributes, delegate_hash = T.unsafe(nil)); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:70
  def ==(other); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:38
  def [](key); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:42
  def []=(key, value); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:49
  def deep_dup; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:23
  def each_key(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:23
  def each_value(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:23
  def except(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:23
  def fetch(*args, &block); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:34
  def key?(key); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:78
  def marshal_dump; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:82
  def marshal_load(values); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:60
  def select; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:23
  def transform_values(*args, &block); end

  protected

  # Returns the value of attribute additional_types.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:94
  def additional_types; end

  # Returns the value of attribute default_attributes.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:94
  def default_attributes; end

  # Returns the value of attribute delegate_hash.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:94
  def delegate_hash; end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:96
  def materialize; end

  # Returns the value of attribute types.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:94
  def types; end

  # Returns the value of attribute values.
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:94
  def values; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:109
  def assign_default_value(name); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_set/builder.rb:55
  def initialize_dup(_); end
end

# source://activemodel-5.2.8.1/lib/active_model/lint.rb:4
module ActiveModel::Lint; end

# == Active \Model \Lint \Tests
#
# You can test whether an object is compliant with the Active \Model API by
# including <tt>ActiveModel::Lint::Tests</tt> in your TestCase. It will
# include tests that tell you whether your object is fully compliant,
# or if not, which aspects of the API are not implemented.
#
# Note an object is not required to implement all APIs in order to work
# with Action Pack. This module only intends to provide guidance in case
# you want all features out of the box.
#
# These tests do not attempt to determine the semantic correctness of the
# returned values. For instance, you could implement <tt>valid?</tt> to
# always return +true+, and the tests would pass. It is up to you to ensure
# that the values are semantically meaningful.
#
# Objects you pass in are expected to return a compliant object from a call
# to <tt>to_model</tt>. It is perfectly fine for <tt>to_model</tt> to return
# +self+.
#
# source://activemodel-5.2.8.1/lib/active_model/lint.rb:24
module ActiveModel::Lint::Tests
  # Passes if the object's model responds to <tt>errors</tt> and if calling
  # <tt>[](attribute)</tt> on the result of this method returns an array.
  # Fails otherwise.
  #
  # <tt>errors[attribute]</tt> is used to retrieve the errors of a model
  # for a given attribute. If errors are present, the method should return
  # an array of strings that are the errors for the attribute in question.
  # If localization is used, the strings should be localized for the current
  # locale. If no error is present, the method should return an empty array.
  #
  # source://activemodel-5.2.8.1/lib/active_model/lint.rb:102
  def test_errors_aref; end

  # Passes if the object's model responds to <tt>model_name</tt> both as
  # an instance method and as a class method, and if calling this method
  # returns a string with some convenience methods: <tt>:human</tt>,
  # <tt>:singular</tt> and <tt>:plural</tt>.
  #
  # Check ActiveModel::Naming for more information.
  #
  # source://activemodel-5.2.8.1/lib/active_model/lint.rb:81
  def test_model_naming; end

  # Passes if the object's model responds to <tt>persisted?</tt> and if
  # calling this method returns either +true+ or +false+. Fails otherwise.
  #
  # <tt>persisted?</tt> is used when calculating the URL for an object.
  # If the object is not persisted, a form for that object, for instance,
  # will route to the create action. If it is persisted, a form for the
  # object will route to the update action.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/lint.rb:70
  def test_persisted?; end

  # Passes if the object's model responds to <tt>to_key</tt> and if calling
  # this method returns +nil+ when the object is not persisted.
  # Fails otherwise.
  #
  # <tt>to_key</tt> returns an Enumerable of all (primary) key attributes
  # of the model, and is used to a generate unique DOM id for the object.
  #
  # source://activemodel-5.2.8.1/lib/active_model/lint.rb:31
  def test_to_key; end

  # Passes if the object's model responds to <tt>to_param</tt> and if
  # calling this method returns +nil+ when the object is not persisted.
  # Fails otherwise.
  #
  # <tt>to_param</tt> is used to represent the object's key in URLs.
  # Implementers can decide to either raise an exception or provide a
  # default in case the record uses a composite primary key. There are no
  # tests for this behavior in lint because it doesn't make sense to force
  # any of the possible implementation strategies on the implementer.
  #
  # source://activemodel-5.2.8.1/lib/active_model/lint.rb:46
  def test_to_param; end

  # Passes if the object's model responds to <tt>to_partial_path</tt> and if
  # calling this method returns a string. Fails otherwise.
  #
  # <tt>to_partial_path</tt> is used for looking up partials. For example,
  # a BlogPost model might return "blog_posts/blog_post".
  #
  # source://activemodel-5.2.8.1/lib/active_model/lint.rb:58
  def test_to_partial_path; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/lint.rb:113
  def assert_boolean(result, name); end

  # source://activemodel-5.2.8.1/lib/active_model/lint.rb:108
  def model; end
end

# Raised when an attribute is not defined.
#
#   class User < ActiveRecord::Base
#     has_many :pets
#   end
#
#   user = User.first
#   user.pets.select(:id).first.user_id
#   # => ActiveModel::MissingAttributeError: missing attribute: user_id
#
# source://activemodel-5.2.8.1/lib/active_model/attribute_methods.rb:15
class ActiveModel::MissingAttributeError < ::NoMethodError; end

# == Active \Model \Basic \Model
#
# Includes the required interface for an object to interact with
# Action Pack and Action View, using different Active Model modules.
# It includes model name introspections, conversions, translations and
# validations. Besides that, it allows you to initialize the object with a
# hash of attributes, pretty much like Active Record does.
#
# A minimal implementation could be:
#
#   class Person
#     include ActiveModel::Model
#     attr_accessor :name, :age
#   end
#
#   person = Person.new(name: 'bob', age: '18')
#   person.name # => "bob"
#   person.age  # => "18"
#
# Note that, by default, <tt>ActiveModel::Model</tt> implements <tt>persisted?</tt>
# to return +false+, which is the most common case. You may want to override
# it in your class to simulate a different scenario:
#
#   class Person
#     include ActiveModel::Model
#     attr_accessor :id, :name
#
#     def persisted?
#       self.id == 1
#     end
#   end
#
#   person = Person.new(id: 1, name: 'bob')
#   person.persisted? # => true
#
# Also, if for some reason you need to run code on <tt>initialize</tt>, make
# sure you call +super+ if you want the attributes hash initialization to
# happen.
#
#   class Person
#     include ActiveModel::Model
#     attr_accessor :id, :name, :omg
#
#     def initialize(attributes={})
#       super
#       @omg ||= true
#     end
#   end
#
#   person = Person.new(id: 1, name: 'bob')
#   person.omg # => true
#
# For more detailed information on other functionalities available, please
# refer to the specific modules included in <tt>ActiveModel::Model</tt>
# (see below).
#
# source://activemodel-5.2.8.1/lib/active_model/model.rb:59
module ActiveModel::Model
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations
  include ::ActiveModel::Conversion

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods
  mixes_in_class_methods ::ActiveModel::Conversion::ClassMethods

  # Initializes a new model with the given +params+.
  #
  #   class Person
  #     include ActiveModel::Model
  #     attr_accessor :name, :age
  #   end
  #
  #   person = Person.new(name: 'bob', age: '18')
  #   person.name # => "bob"
  #   person.age  # => "18"
  #
  # source://activemodel-5.2.8.1/lib/active_model/model.rb:80
  def initialize(attributes = T.unsafe(nil)); end

  # Indicates if the model is persisted. Default is +false+.
  #
  #  class Person
  #    include ActiveModel::Model
  #    attr_accessor :id, :name
  #  end
  #
  #  person = Person.new(id: 1, name: 'bob')
  #  person.persisted? # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/model.rb:95
  def persisted?; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/naming.rb:8
class ActiveModel::Name
  include ::Comparable

  # Returns a new ActiveModel::Name instance. By default, the +namespace+
  # and +name+ option will take the namespace and name of the given class
  # respectively.
  #
  #   module Foo
  #     class Bar
  #     end
  #   end
  #
  #   ActiveModel::Name.new(Foo::Bar).to_s
  #   # => "Foo::Bar"
  #
  # @raise [ArgumentError]
  # @return [Name] a new instance of Name
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:148
  def initialize(klass, namespace = T.unsafe(nil), name = T.unsafe(nil)); end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def !~(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def <=>(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def ==(arg); end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def ===(arg); end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def =~(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def as_json(*args, &block); end

  # Returns the value of attribute collection.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def cache_key; end

  # Returns the value of attribute collection.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def collection; end

  # Returns the value of attribute element.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def element; end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def eql?(*args, &block); end

  # Transform the model name into a more human format, using I18n. By default,
  # it will underscore then humanize the class name.
  #
  #   class BlogPost
  #     extend ActiveModel::Naming
  #   end
  #
  #   BlogPost.model_name.human # => "Blog post"
  #
  # Specify +options+ with additional translating options.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:178
  def human(options = T.unsafe(nil)); end

  # Returns the value of attribute i18n_key.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def i18n_key; end

  # Returns the value of attribute name.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def name; end

  # Returns the value of attribute param_key.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def param_key; end

  # Returns the value of attribute plural.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def plural; end

  # Returns the value of attribute route_key.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def route_key; end

  # Returns the value of attribute singular.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def singular; end

  # Returns the value of attribute singular_route_key.
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:11
  def singular_route_key; end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def to_s(*args, &block); end

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:134
  def to_str(*args, &block); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:195
  def _singularize(string); end
end

# == Active \Model \Naming
#
# Creates a +model_name+ method on your object.
#
# To implement, just extend ActiveModel::Naming in your object:
#
#   class BookCover
#     extend ActiveModel::Naming
#   end
#
#   BookCover.model_name.name   # => "BookCover"
#   BookCover.model_name.human  # => "Book cover"
#
#   BookCover.model_name.i18n_key              # => :book_cover
#   BookModule::BookCover.model_name.i18n_key  # => :"book_module/book_cover"
#
# Providing the functionality that ActiveModel::Naming provides in your object
# is required to pass the \Active \Model Lint test. So either extending the
# provided method below, or rolling your own is required.
#
# source://activemodel-5.2.8.1/lib/active_model/naming.rb:219
module ActiveModel::Naming
  # Returns an ActiveModel::Name object for module. It can be
  # used to retrieve all kinds of naming-related information
  # (See ActiveModel::Name for more information).
  #
  #   class Person
  #     extend ActiveModel::Naming
  #   end
  #
  #   Person.model_name.name     # => "Person"
  #   Person.model_name.class    # => ActiveModel::Name
  #   Person.model_name.singular # => "person"
  #   Person.model_name.plural   # => "people"
  #
  # source://activemodel-5.2.8.1/lib/active_model/naming.rb:237
  def model_name; end

  class << self
    # source://activemodel-5.2.8.1/lib/active_model/naming.rb:220
    def extended(base); end

    # Returns string to use for params names. It differs for
    # namespaced models regarding whether it's inside isolated engine.
    #
    #   # For isolated engine:
    #   ActiveModel::Naming.param_key(Blog::Post) # => "post"
    #
    #   # For shared engine:
    #   ActiveModel::Naming.param_key(Blog::Post) # => "blog_post"
    #
    # source://activemodel-5.2.8.1/lib/active_model/naming.rb:305
    def param_key(record_or_class); end

    # Returns the plural class name of a record or class.
    #
    #   ActiveModel::Naming.plural(post)             # => "posts"
    #   ActiveModel::Naming.plural(Highrise::Person) # => "highrise_people"
    #
    # source://activemodel-5.2.8.1/lib/active_model/naming.rb:250
    def plural(record_or_class); end

    # Returns string to use while generating route names. It differs for
    # namespaced models regarding whether it's inside isolated engine.
    #
    #   # For isolated engine:
    #   ActiveModel::Naming.route_key(Blog::Post) # => "posts"
    #
    #   # For shared engine:
    #   ActiveModel::Naming.route_key(Blog::Post) # => "blog_posts"
    #
    # The route key also considers if the noun is uncountable and, in
    # such cases, automatically appends _index.
    #
    # source://activemodel-5.2.8.1/lib/active_model/naming.rb:293
    def route_key(record_or_class); end

    # Returns the singular class name of a record or class.
    #
    #   ActiveModel::Naming.singular(post)             # => "post"
    #   ActiveModel::Naming.singular(Highrise::Person) # => "highrise_person"
    #
    # source://activemodel-5.2.8.1/lib/active_model/naming.rb:258
    def singular(record_or_class); end

    # Returns string to use while generating route names. It differs for
    # namespaced models regarding whether it's inside isolated engine.
    #
    #   # For isolated engine:
    #   ActiveModel::Naming.singular_route_key(Blog::Post) # => "post"
    #
    #   # For shared engine:
    #   ActiveModel::Naming.singular_route_key(Blog::Post) # => "blog_post"
    #
    # source://activemodel-5.2.8.1/lib/active_model/naming.rb:278
    def singular_route_key(record_or_class); end

    # Identifies whether the class name of a record or class is uncountable.
    #
    #   ActiveModel::Naming.uncountable?(Sheep) # => true
    #   ActiveModel::Naming.uncountable?(Post)  # => false
    #
    # @return [Boolean]
    #
    # source://activemodel-5.2.8.1/lib/active_model/naming.rb:266
    def uncountable?(record_or_class); end

    private

    # source://activemodel-5.2.8.1/lib/active_model/naming.rb:309
    def model_name_from_record_or_class(record_or_class); end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:85
class ActiveModel::NullMutationTracker
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:103
  def any_changes?(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:100
  def change_to_attribute(attr_name); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:107
  def changed?(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:88
  def changed_attribute_names(*_arg0); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:111
  def changed_in_place?(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:92
  def changed_values(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:96
  def changes(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:121
  def force_change(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:115
  def forget_change(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/attribute_mutation_tracker.rb:118
  def original_value(*_arg0); end
end

# source://activemodel-5.2.8.1/lib/active_model/railtie.rb:7
class ActiveModel::Railtie < ::Rails::Railtie; end

# Raised when attribute values are out of range.
#
# source://activemodel-5.2.8.1/lib/active_model/errors.rb:495
class ActiveModel::RangeError < ::RangeError; end

# source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:4
module ActiveModel::SecurePassword
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveModel::SecurePassword::ClassMethods

  class << self
    # source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:13
    def min_cost; end

    # source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:13
    def min_cost=(_arg0); end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:17
module ActiveModel::SecurePassword::ClassMethods
  # Adds methods to set and authenticate against a BCrypt password.
  # This mechanism requires you to have a +password_digest+ attribute.
  #
  # The following validations are added automatically:
  # * Password must be present on creation
  # * Password length should be less than or equal to 72 bytes
  # * Confirmation of password (using a +password_confirmation+ attribute)
  #
  # If password confirmation validation is not needed, simply leave out the
  # value for +password_confirmation+ (i.e. don't provide a form field for
  # it). When this attribute has a +nil+ value, the validation will not be
  # triggered.
  #
  # For further customizability, it is possible to suppress the default
  # validations by passing <tt>validations: false</tt> as an argument.
  #
  # Add bcrypt (~> 3.1.7) to Gemfile to use #has_secure_password:
  #
  #   gem 'bcrypt', '~> 3.1.7'
  #
  # Example using Active Record (which automatically includes ActiveModel::SecurePassword):
  #
  #   # Schema: User(name:string, password_digest:string)
  #   class User < ActiveRecord::Base
  #     has_secure_password
  #   end
  #
  #   user = User.new(name: 'david', password: '', password_confirmation: 'nomatch')
  #   user.save                                                       # => false, password required
  #   user.password = 'mUc3m00RsqyRe'
  #   user.save                                                       # => false, confirmation doesn't match
  #   user.password_confirmation = 'mUc3m00RsqyRe'
  #   user.save                                                       # => true
  #   user.authenticate('notright')                                   # => false
  #   user.authenticate('mUc3m00RsqyRe')                              # => user
  #   User.find_by(name: 'david').try(:authenticate, 'notright')      # => false
  #   User.find_by(name: 'david').try(:authenticate, 'mUc3m00RsqyRe') # => user
  #
  # source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:55
  def has_secure_password(options = T.unsafe(nil)); end
end

# source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:85
module ActiveModel::SecurePassword::InstanceMethodsOnActivation
  # Returns +self+ if the password is correct, otherwise +false+.
  #
  #   class User < ActiveRecord::Base
  #     has_secure_password validations: false
  #   end
  #
  #   user = User.new(name: 'david', password: 'mUc3m00RsqyRe')
  #   user.save
  #   user.authenticate('notright')      # => false
  #   user.authenticate('mUc3m00RsqyRe') # => user
  #
  # source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:96
  def authenticate(unencrypted_password); end

  # Returns the value of attribute password.
  #
  # source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:100
  def password; end

  # Encrypts the password into the +password_digest+ attribute, only if the
  # new password is not empty.
  #
  #   class User < ActiveRecord::Base
  #     has_secure_password validations: false
  #   end
  #
  #   user = User.new
  #   user.password = nil
  #   user.password_digest # => nil
  #   user.password = 'mUc3m00RsqyRe'
  #   user.password_digest # => "$2a$10$4LEA7r4YmNHtvlAvHhsYAeZmk/xeUVtMTYqwIvYY76EW5GUqDiP4."
  #
  # source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:114
  def password=(unencrypted_password); end

  # source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:124
  def password_confirmation=(unencrypted_password); end
end

# BCrypt hash function can handle maximum 72 bytes, and if we pass
# password of length more than 72 bytes it ignores extra characters.
# Hence need to put a restriction on password length.
#
# source://activemodel-5.2.8.1/lib/active_model/secure_password.rb:10
ActiveModel::SecurePassword::MAX_PASSWORD_LENGTH_ALLOWED = T.let(T.unsafe(nil), Integer)

# == Active \Model \Serialization
#
# Provides a basic serialization to a serializable_hash for your objects.
#
# A minimal implementation could be:
#
#   class Person
#     include ActiveModel::Serialization
#
#     attr_accessor :name
#
#     def attributes
#       {'name' => nil}
#     end
#   end
#
# Which would provide you with:
#
#   person = Person.new
#   person.serializable_hash   # => {"name"=>nil}
#   person.name = "Bob"
#   person.serializable_hash   # => {"name"=>"Bob"}
#
# An +attributes+ hash must be defined and should contain any attributes you
# need to be serialized. Attributes must be strings, not symbols.
# When called, serializable hash will use instance methods that match the name
# of the attributes hash's keys. In order to override this behavior, take a look
# at the private method +read_attribute_for_serialization+.
#
# ActiveModel::Serializers::JSON module automatically includes
# the <tt>ActiveModel::Serialization</tt> module, so there is no need to
# explicitly include <tt>ActiveModel::Serialization</tt>.
#
# A minimal implementation including JSON would be:
#
#   class Person
#     include ActiveModel::Serializers::JSON
#
#     attr_accessor :name
#
#     def attributes
#       {'name' => nil}
#     end
#   end
#
# Which would provide you with:
#
#   person = Person.new
#   person.serializable_hash   # => {"name"=>nil}
#   person.as_json             # => {"name"=>nil}
#   person.to_json             # => "{\"name\":null}"
#
#   person.name = "Bob"
#   person.serializable_hash   # => {"name"=>"Bob"}
#   person.as_json             # => {"name"=>"Bob"}
#   person.to_json             # => "{\"name\":\"Bob\"}"
#
# Valid options are <tt>:only</tt>, <tt>:except</tt>, <tt>:methods</tt> and
# <tt>:include</tt>. The following are all valid examples:
#
#   person.serializable_hash(only: 'name')
#   person.serializable_hash(include: :address)
#   person.serializable_hash(include: { address: { only: 'city' }})
#
# source://activemodel-5.2.8.1/lib/active_model/serialization.rb:70
module ActiveModel::Serialization
  # Hook method defining how an attribute value should be retrieved for
  # serialization. By default this is assumed to be an instance named after
  # the attribute. Override this method in subclasses should you need to
  # retrieve the value for a given attribute differently:
  #
  #   class MyClass
  #     include ActiveModel::Serialization
  #
  #     def initialize(data = {})
  #       @data = data
  #     end
  #
  #     def read_attribute_for_serialization(key)
  #       @data[key]
  #     end
  #   end
  def read_attribute_for_serialization(*_arg0); end

  # Returns a serialized hash of your object.
  #
  #   class Person
  #     include ActiveModel::Serialization
  #
  #     attr_accessor :name, :age
  #
  #     def attributes
  #       {'name' => nil, 'age' => nil}
  #     end
  #
  #     def capitalized_name
  #       name.capitalize
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name = 'bob'
  #   person.age  = 22
  #   person.serializable_hash                # => {"name"=>"bob", "age"=>22}
  #   person.serializable_hash(only: :name)   # => {"name"=>"bob"}
  #   person.serializable_hash(except: :name) # => {"age"=>22}
  #   person.serializable_hash(methods: :capitalized_name)
  #   # => {"name"=>"bob", "age"=>22, "capitalized_name"=>"Bob"}
  #
  # Example with <tt>:include</tt> option
  #
  #   class User
  #     include ActiveModel::Serializers::JSON
  #     attr_accessor :name, :notes # Emulate has_many :notes
  #     def attributes
  #       {'name' => nil}
  #     end
  #   end
  #
  #   class Note
  #     include ActiveModel::Serializers::JSON
  #     attr_accessor :title, :text
  #     def attributes
  #       {'title' => nil, 'text' => nil}
  #     end
  #   end
  #
  #   note = Note.new
  #   note.title = 'Battle of Austerlitz'
  #   note.text = 'Some text here'
  #
  #   user = User.new
  #   user.name = 'Napoleon'
  #   user.notes = [note]
  #
  #   user.serializable_hash
  #   # => {"name" => "Napoleon"}
  #   user.serializable_hash(include: { notes: { only: 'title' }})
  #   # => {"name" => "Napoleon", "notes" => [{"title"=>"Battle of Austerlitz"}]}
  #
  # source://activemodel-5.2.8.1/lib/active_model/serialization.rb:126
  def serializable_hash(options = T.unsafe(nil)); end

  private

  # Add associations specified via the <tt>:include</tt> option.
  #
  # Expects a block that takes as arguments:
  #   +association+ - name of the association
  #   +records+     - the association record(s) to be serialized
  #   +opts+        - options for the association records
  #
  # source://activemodel-5.2.8.1/lib/active_model/serialization.rb:178
  def serializable_add_includes(options = T.unsafe(nil)); end
end

# source://activemodel-5.2.8.1/lib/active_model.rb:61
module ActiveModel::Serializers
  extend ::ActiveSupport::Autoload
end

# == Active \Model \JSON \Serializer
#
# source://activemodel-5.2.8.1/lib/active_model/serializers/json.rb:8
module ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Naming

  # Returns a hash representing the model. Some configuration can be
  # passed through +options+.
  #
  # The option <tt>include_root_in_json</tt> controls the top-level behavior
  # of +as_json+. If +true+, +as_json+ will emit a single root node named
  # after the object's type. The default value for <tt>include_root_in_json</tt>
  # option is +false+.
  #
  #   user = User.find(1)
  #   user.as_json
  #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
  #   #     "created_at" => "2006/08/01", "awesome" => true}
  #
  #   ActiveRecord::Base.include_root_in_json = true
  #
  #   user.as_json
  #   # => { "user" => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
  #   #                  "created_at" => "2006/08/01", "awesome" => true } }
  #
  # This behavior can also be achieved by setting the <tt>:root</tt> option
  # to +true+ as in:
  #
  #   user = User.find(1)
  #   user.as_json(root: true)
  #   # => { "user" => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
  #   #                  "created_at" => "2006/08/01", "awesome" => true } }
  #
  # Without any +options+, the returned Hash will include all the model's
  # attributes.
  #
  #   user = User.find(1)
  #   user.as_json
  #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
  #   #      "created_at" => "2006/08/01", "awesome" => true}
  #
  # The <tt>:only</tt> and <tt>:except</tt> options can be used to limit
  # the attributes included, and work similar to the +attributes+ method.
  #
  #   user.as_json(only: [:id, :name])
  #   # => { "id" => 1, "name" => "Konata Izumi" }
  #
  #   user.as_json(except: [:id, :created_at, :age])
  #   # => { "name" => "Konata Izumi", "awesome" => true }
  #
  # To include the result of some method calls on the model use <tt>:methods</tt>:
  #
  #   user.as_json(methods: :permalink)
  #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
  #   #      "created_at" => "2006/08/01", "awesome" => true,
  #   #      "permalink" => "1-konata-izumi" }
  #
  # To include associations use <tt>:include</tt>:
  #
  #   user.as_json(include: :posts)
  #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
  #   #      "created_at" => "2006/08/01", "awesome" => true,
  #   #      "posts" => [ { "id" => 1, "author_id" => 1, "title" => "Welcome to the weblog" },
  #   #                   { "id" => 2, "author_id" => 1, "title" => "So I was thinking" } ] }
  #
  # Second level and higher order associations work as well:
  #
  #   user.as_json(include: { posts: {
  #                              include: { comments: {
  #                                             only: :body } },
  #                              only: :title } })
  #   # => { "id" => 1, "name" => "Konata Izumi", "age" => 16,
  #   #      "created_at" => "2006/08/01", "awesome" => true,
  #   #      "posts" => [ { "comments" => [ { "body" => "1st post!" }, { "body" => "Second!" } ],
  #   #                     "title" => "Welcome to the weblog" },
  #   #                   { "comments" => [ { "body" => "Don't think too hard" } ],
  #   #                     "title" => "So I was thinking" } ] }
  #
  # source://activemodel-5.2.8.1/lib/active_model/serializers/json.rb:89
  def as_json(options = T.unsafe(nil)); end

  # Sets the model +attributes+ from a JSON string. Returns +self+.
  #
  #   class Person
  #     include ActiveModel::Serializers::JSON
  #
  #     attr_accessor :name, :age, :awesome
  #
  #     def attributes=(hash)
  #       hash.each do |key, value|
  #         send("#{key}=", value)
  #       end
  #     end
  #
  #     def attributes
  #       instance_values
  #     end
  #   end
  #
  #   json = { name: 'bob', age: 22, awesome:true }.to_json
  #   person = Person.new
  #   person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
  #   person.name            # => "bob"
  #   person.age             # => 22
  #   person.awesome         # => true
  #
  # The default value for +include_root+ is +false+. You can change it to
  # +true+ if the given JSON string includes a single root node.
  #
  #   json = { person: { name: 'bob', age: 22, awesome:true } }.to_json
  #   person = Person.new
  #   person.from_json(json, true) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name="bob">
  #   person.name                  # => "bob"
  #   person.age                   # => 22
  #   person.awesome               # => true
  #
  # source://activemodel-5.2.8.1/lib/active_model/serializers/json.rb:138
  def from_json(json, include_root = T.unsafe(nil)); end

  module GeneratedClassMethods
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
  end

  module GeneratedInstanceMethods
    def include_root_in_json; end
    def include_root_in_json?; end
  end
end

# Raised when a validation cannot be corrected by end users and are considered
# exceptional.
#
#   class Person
#     include ActiveModel::Validations
#
#     attr_accessor :name
#
#     validates_presence_of :name, strict: true
#   end
#
#   person = Person.new
#   person.name = nil
#   person.valid?
#   # => ActiveModel::StrictValidationFailed: Name can't be blank
#
# source://activemodel-5.2.8.1/lib/active_model/errors.rb:491
class ActiveModel::StrictValidationFailed < ::StandardError; end

# == Active \Model \Translation
#
# Provides integration between your object and the Rails internationalization
# (i18n) framework.
#
# A minimal implementation could be:
#
#   class TranslatedPerson
#     extend ActiveModel::Translation
#   end
#
#   TranslatedPerson.human_attribute_name('my_attribute')
#   # => "My attribute"
#
# This also provides the required class methods for hooking into the
# Rails internationalization API, including being able to define a
# class based +i18n_scope+ and +lookup_ancestors+ to find translations in
# parent classes.
#
# source://activemodel-5.2.8.1/lib/active_model/translation.rb:22
module ActiveModel::Translation
  include ::ActiveModel::Naming

  # Transforms attribute names into a more human format, such as "First name"
  # instead of "first_name".
  #
  #   Person.human_attribute_name("first_name") # => "First name"
  #
  # Specify +options+ with additional translating options.
  #
  # source://activemodel-5.2.8.1/lib/active_model/translation.rb:44
  def human_attribute_name(attribute, options = T.unsafe(nil)); end

  # Returns the +i18n_scope+ for the class. Overwrite if you want custom lookup.
  #
  # source://activemodel-5.2.8.1/lib/active_model/translation.rb:26
  def i18n_scope; end

  # When localizing a string, it goes through the lookup returned by this
  # method, which is used in ActiveModel::Name#human,
  # ActiveModel::Errors#full_messages and
  # ActiveModel::Translation#human_attribute_name.
  #
  # source://activemodel-5.2.8.1/lib/active_model/translation.rb:34
  def lookup_ancestors; end
end

# :stopdoc:
#
# source://activemodel-5.2.8.1/lib/active_model/type/helpers/accepts_multiparameter_time.rb:4
module ActiveModel::Type
  class << self
    # source://activemodel-5.2.8.1/lib/active_model/type.rb:36
    def default_value; end

    # source://activemodel-5.2.8.1/lib/active_model/type.rb:32
    def lookup(*args, **kwargs); end

    # Add a new type to the registry, allowing it to be gotten through ActiveModel::Type#lookup
    #
    # source://activemodel-5.2.8.1/lib/active_model/type.rb:28
    def register(type_name, klass = T.unsafe(nil), **options, &block); end

    # source://activemodel-5.2.8.1/lib/active_model/type.rb:25
    def registry; end

    # source://activemodel-5.2.8.1/lib/active_model/type.rb:25
    def registry=(_arg0); end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/type/big_integer.rb:7
class ActiveModel::Type::BigInteger < ::ActiveModel::Type::Integer
  private

  # source://activemodel-5.2.8.1/lib/active_model/type/big_integer.rb:10
  def max_value; end
end

# source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:5
class ActiveModel::Type::Binary < ::ActiveModel::Type::Value
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:10
  def binary?; end

  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:14
  def cast(value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:27
  def changed_in_place?(raw_old_value, value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:22
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:6
  def type; end
end

# source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:32
class ActiveModel::Type::Binary::Data
  # @return [Data] a new instance of Data
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:33
  def initialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:46
  def ==(other); end

  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:42
  def hex; end

  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:37
  def to_s; end

  # source://activemodel-5.2.8.1/lib/active_model/type/binary.rb:37
  def to_str; end
end

# == Active \Model \Type \Boolean
#
# A class that behaves like a boolean type, including rules for coercion of user input.
#
# === Coercion
# Values set from user input will first be coerced into the appropriate ruby type.
# Coercion behavior is roughly mapped to Ruby's boolean semantics.
#
# - "false", "f" , "0", +0+ or any other value in +FALSE_VALUES+ will be coerced to +false+
# - Empty strings are coerced to +nil+
# - All other values will be coerced to +true+
#
# source://activemodel-5.2.8.1/lib/active_model/type/boolean.rb:16
class ActiveModel::Type::Boolean < ::ActiveModel::Type::Value
  # source://activemodel-5.2.8.1/lib/active_model/type/boolean.rb:32
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/boolean.rb:28
  def type; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/boolean.rb:38
  def cast_value(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/boolean.rb:17
ActiveModel::Type::Boolean::FALSE_VALUES = T.let(T.unsafe(nil), Set)

# source://activemodel-5.2.8.1/lib/active_model/type/date.rb:5
class ActiveModel::Type::Date < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Timezone

  # source://activemodel-5.2.8.1/lib/active_model/type/date.rb:13
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/date.rb:9
  def type; end

  # source://activemodel-5.2.8.1/lib/active_model/type/date.rb:17
  def type_cast_for_schema(value); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/date.rb:23
  def cast_value(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/date.rb:41
  def fallback_string_to_date(string); end

  # source://activemodel-5.2.8.1/lib/active_model/type/date.rb:35
  def fast_string_to_date(string); end

  # source://activemodel-5.2.8.1/lib/active_model/type/date.rb:45
  def new_date(year, mon, mday); end

  # source://activemodel-5.2.8.1/lib/active_model/type/date.rb:51
  def value_from_multiparameter_assignment(*_arg0); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/date.rb:34
ActiveModel::Type::Date::ISO_DATE = T.let(T.unsafe(nil), Regexp)

# source://activemodel-5.2.8.1/lib/active_model/type/date_time.rb:5
class ActiveModel::Type::DateTime < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue

  # source://activemodel-5.2.8.1/lib/active_model/type/date_time.rb:16
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/date_time.rb:12
  def type; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/date_time.rb:22
  def cast_value(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/date_time.rb:35
  def fallback_string_to_time(string); end

  # '0.123456' -> 123456
  # '1.123456' -> 123456
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/date_time.rb:31
  def microseconds(time); end

  # source://activemodel-5.2.8.1/lib/active_model/type/date_time.rb:42
  def value_from_multiparameter_assignment(values_hash); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/decimal.rb:7
class ActiveModel::Type::Decimal < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Numeric

  # source://activemodel-5.2.8.1/lib/active_model/type/decimal.rb:11
  def type; end

  # source://activemodel-5.2.8.1/lib/active_model/type/decimal.rb:15
  def type_cast_for_schema(value); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/decimal.rb:61
  def apply_scale(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/decimal.rb:21
  def cast_value(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/decimal.rb:45
  def convert_float_to_big_decimal(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/decimal.rb:53
  def float_precision; end
end

# source://activemodel-5.2.8.1/lib/active_model/type/decimal.rb:9
ActiveModel::Type::Decimal::BIGDECIMAL_PRECISION = T.let(T.unsafe(nil), Integer)

# source://activemodel-5.2.8.1/lib/active_model/type/float.rb:5
class ActiveModel::Type::Float < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Numeric

  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/numeric.rb:7
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/float.rb:8
  def type; end

  # source://activemodel-5.2.8.1/lib/active_model/type/float.rb:12
  def type_cast_for_schema(value); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/float.rb:25
  def cast_value(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/helpers/accepts_multiparameter_time.rb:5
module ActiveModel::Type::Helpers; end

# source://activemodel-5.2.8.1/lib/active_model/type/helpers/accepts_multiparameter_time.rb:6
class ActiveModel::Type::Helpers::AcceptsMultiparameterTime < ::Module
  # @return [AcceptsMultiparameterTime] a new instance of AcceptsMultiparameterTime
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/accepts_multiparameter_time.rb:7
  def initialize(defaults: T.unsafe(nil)); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/helpers/mutable.rb:6
module ActiveModel::Type::Helpers::Mutable
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/mutable.rb:7
  def cast(value); end

  # +raw_old_value+ will be the `_before_type_cast` version of the
  # value (likely a string). +new_value+ will be the current, type
  # cast value.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/mutable.rb:14
  def changed_in_place?(raw_old_value, new_value); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/helpers/numeric.rb:6
module ActiveModel::Type::Helpers::Numeric
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/numeric.rb:7
  def cast(value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/numeric.rb:18
  def changed?(old_value, _new_value, new_value_before_type_cast); end

  private

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/numeric.rb:28
  def non_numeric_string?(value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/numeric.rb:24
  def number_to_non_number?(old_value, new_value_before_type_cast); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/helpers/time_value.rb:9
module ActiveModel::Type::Helpers::TimeValue
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/time_value.rb:24
  def apply_seconds_precision(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/time_value.rb:10
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/time_value.rb:31
  def type_cast_for_schema(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/time_value.rb:35
  def user_input_in_time_zone(value); end

  private

  # Doesn't handle time zones.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/time_value.rb:59
  def fast_string_to_time(string); end

  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/time_value.rb:41
  def new_time(year, mon, mday, hour, min, sec, microsec, offset = T.unsafe(nil)); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/helpers/time_value.rb:56
ActiveModel::Type::Helpers::TimeValue::ISO_DATETIME = T.let(T.unsafe(nil), Regexp)

# source://activemodel-5.2.8.1/lib/active_model/type/helpers/timezone.rb:8
module ActiveModel::Type::Helpers::Timezone
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/timezone.rb:13
  def default_timezone; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/helpers/timezone.rb:9
  def is_utc?; end
end

# source://activemodel-5.2.8.1/lib/active_model/type/immutable_string.rb:5
class ActiveModel::Type::ImmutableString < ::ActiveModel::Type::Value
  # source://activemodel-5.2.8.1/lib/active_model/type/immutable_string.rb:10
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/immutable_string.rb:6
  def type; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/immutable_string.rb:21
  def cast_value(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:5
class ActiveModel::Type::Integer < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Numeric

  # @return [Integer] a new instance of Integer
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:12
  def initialize(*_arg0); end

  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:21
  def deserialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:26
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:17
  def type; end

  protected

  # Returns the value of attribute range.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:38
  def range; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:65
  def _limit; end

  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:42
  def cast_value(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:51
  def ensure_in_range(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:57
  def max_value; end

  # source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:61
  def min_value; end
end

# Column storage size in bytes.
# 4 bytes means an integer as opposed to smallint etc.
#
# source://activemodel-5.2.8.1/lib/active_model/type/integer.rb:10
ActiveModel::Type::Integer::DEFAULT_LIMIT = T.let(T.unsafe(nil), Integer)

# source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:43
class ActiveModel::Type::Registration
  # Options must be taken because of https://bugs.ruby-lang.org/issues/10856
  #
  # @return [Registration] a new instance of Registration
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:45
  def initialize(name, block, **_arg2); end

  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:50
  def call(_registry, *args, **kwargs); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:58
  def matches?(type_name, *args, **kwargs); end

  protected

  # Returns the value of attribute block.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:66
  def block; end

  # Returns the value of attribute name.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:66
  def name; end
end

# source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:6
class ActiveModel::Type::Registry
  # @return [Registry] a new instance of Registry
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:7
  def initialize; end

  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:16
  def lookup(symbol, *args); end

  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:11
  def register(type_name, klass = T.unsafe(nil), **options, &block); end

  protected

  # Returns the value of attribute registrations.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:30
  def registrations; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:38
  def find_registration(symbol, *args); end

  # source://activemodel-5.2.8.1/lib/active_model/type/registry.rb:34
  def registration_klass; end
end

# source://activemodel-5.2.8.1/lib/active_model/type/string.rb:7
class ActiveModel::Type::String < ::ActiveModel::Type::ImmutableString
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/string.rb:8
  def changed_in_place?(raw_old_value, new_value); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/string.rb:16
  def cast_value(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/time.rb:5
class ActiveModel::Type::Time < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue

  # source://activemodel-5.2.8.1/lib/active_model/type/time.rb:16
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/time.rb:12
  def type; end

  # source://activemodel-5.2.8.1/lib/active_model/type/time.rb:20
  def user_input_in_time_zone(value); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/type/time.rb:37
  def cast_value(value); end
end

# source://activemodel-5.2.8.1/lib/active_model/type/value.rb:5
class ActiveModel::Type::Value
  # @return [Value] a new instance of Value
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:8
  def initialize(precision: T.unsafe(nil), limit: T.unsafe(nil), scale: T.unsafe(nil)); end

  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:101
  def ==(other); end

  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:113
  def assert_valid_value(*_arg0); end

  # These predicates are not documented, as I need to look further into
  # their use, and see if they can be removed entirely.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:57
  def binary?; end

  # Type casts a value from user input (e.g. from a setter). This value may
  # be a string from the form builder, or a ruby object passed to a setter.
  # There is currently no way to differentiate between which source it came
  # from.
  #
  # The return value of this method will be returned from
  # ActiveRecord::AttributeMethods::Read#read_attribute. See also:
  # Value#cast_value.
  #
  # +value+ The raw input, as provided to the attribute setter.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:37
  def cast(value); end

  # Determines whether a value has changed for dirty checking. +old_value+
  # and +new_value+ will always be type-cast. Types should not need to
  # override this method.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:64
  def changed?(old_value, new_value, _new_value_before_type_cast); end

  # Determines whether the mutable value has been modified since it was
  # read. Returns +false+ by default. If your type returns an object
  # which could be mutated, you should override this method. You will need
  # to either:
  #
  # - pass +new_value+ to Value#serialize and compare it to
  #   +raw_old_value+
  #
  # or
  #
  # - pass +raw_old_value+ to Value#deserialize and compare it to
  #   +new_value+
  #
  # +raw_old_value+ The original value, before being passed to
  # +deserialize+.
  #
  # +new_value+ The current value, after type casting.
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:85
  def changed_in_place?(raw_old_value, new_value); end

  # Converts a value from database input to the appropriate ruby type. The
  # return value of this method will be returned from
  # ActiveRecord::AttributeMethods::Read#read_attribute. The default
  # implementation just calls Value#cast.
  #
  # +value+ The raw input, as provided from the database.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:23
  def deserialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:101
  def eql?(other); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:93
  def force_equality?(_value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:109
  def hash; end

  # Returns the value of attribute limit.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:6
  def limit; end

  # @yield [value]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:97
  def map(value); end

  # Returns the value of attribute precision.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:6
  def precision; end

  # Returns the value of attribute scale.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:6
  def scale; end

  # Casts a value from the ruby type to a type that the database knows how
  # to understand. The returned value from this method should be a
  # +String+, +Numeric+, +Date+, +Time+, +Symbol+, +true+, +false+, or
  # +nil+.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:45
  def serialize(value); end

  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:14
  def type; end

  # Type casts a value for schema dumping. This method is private, as we are
  # hoping to remove it entirely.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:51
  def type_cast_for_schema(value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:89
  def value_constructed_by_mass_assignment?(_value); end

  private

  # Convenience method for types which do not need separate type casting
  # behavior for user and database inputs. Called by Value#cast for
  # values except +nil+.
  #
  # source://activemodel-5.2.8.1/lib/active_model/type/value.rb:121
  def cast_value(value); end
end

# Raised when unknown attributes are supplied via mass assignment.
#
#   class Person
#     include ActiveModel::AttributeAssignment
#     include ActiveModel::Validations
#   end
#
#   person = Person.new
#   person.assign_attributes(name: 'Gorby')
#   # => ActiveModel::UnknownAttributeError: unknown attribute 'name' for Person.
#
# source://activemodel-5.2.8.1/lib/active_model/errors.rb:508
class ActiveModel::UnknownAttributeError < ::NoMethodError
  # @return [UnknownAttributeError] a new instance of UnknownAttributeError
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:511
  def initialize(record, attribute); end

  # Returns the value of attribute attribute.
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:509
  def attribute; end

  # Returns the value of attribute record.
  #
  # source://activemodel-5.2.8.1/lib/active_model/errors.rb:509
  def record; end
end

# source://activemodel-5.2.8.1/lib/active_model/gem_version.rb:9
module ActiveModel::VERSION; end

# source://activemodel-5.2.8.1/lib/active_model/gem_version.rb:10
ActiveModel::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://activemodel-5.2.8.1/lib/active_model/gem_version.rb:11
ActiveModel::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://activemodel-5.2.8.1/lib/active_model/gem_version.rb:13
ActiveModel::VERSION::PRE = T.let(T.unsafe(nil), String)

# source://activemodel-5.2.8.1/lib/active_model/gem_version.rb:15
ActiveModel::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://activemodel-5.2.8.1/lib/active_model/gem_version.rb:12
ActiveModel::VERSION::TINY = T.let(T.unsafe(nil), Integer)

# = Active Model ValidationError
#
# Raised by <tt>validate!</tt> when the model is invalid. Use the
# +model+ method to retrieve the record which did not validate.
#
#   begin
#     complex_operation_that_internally_calls_validate!
#   rescue ActiveModel::ValidationError => invalid
#     puts invalid.model.errors
#   end
#
# source://activemodel-5.2.8.1/lib/active_model/validations.rb:428
class ActiveModel::ValidationError < ::StandardError
  # @return [ValidationError] a new instance of ValidationError
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:431
  def initialize(model); end

  # Returns the value of attribute model.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:429
  def model; end
end

# == Active \Model \Validations
#
# Provides a full validation framework to your objects.
#
# A minimal implementation could be:
#
#   class Person
#     include ActiveModel::Validations
#
#     attr_accessor :first_name, :last_name
#
#     validates_each :first_name, :last_name do |record, attr, value|
#       record.errors.add attr, 'starts with z.' if value.to_s[0] == ?z
#     end
#   end
#
# Which provides you with the full standard validation stack that you
# know from Active Record:
#
#   person = Person.new
#   person.valid?                   # => true
#   person.invalid?                 # => false
#
#   person.first_name = 'zoolander'
#   person.valid?                   # => false
#   person.invalid?                 # => true
#   person.errors.messages          # => {first_name:["starts with z."]}
#
# Note that <tt>ActiveModel::Validations</tt> automatically adds an +errors+
# method to your instances initialized with a new <tt>ActiveModel::Errors</tt>
# object, so there is no need for you to do this manually.
#
# source://activemodel-5.2.8.1/lib/active_model/validations.rb:39
module ActiveModel::Validations
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods

  # Returns the +Errors+ object that holds all information about attribute
  # error messages.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name
  #   end
  #
  #   person = Person.new
  #   person.valid? # => false
  #   person.errors # => #<ActiveModel::Errors:0x007fe603816640 @messages={name:["can't be blank"]}>
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:303
  def errors; end

  # Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were
  # added, +false+ otherwise.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name
  #   end
  #
  #   person = Person.new
  #   person.name = ''
  #   person.invalid? # => true
  #   person.name = 'david'
  #   person.invalid? # => false
  #
  # Context can optionally be supplied to define which callbacks to test
  # against (the context is defined on the validations using <tt>:on</tt>).
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name, on: :new
  #   end
  #
  #   person = Person.new
  #   person.invalid?       # => false
  #   person.invalid?(:new) # => true
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:375
  def invalid?(context = T.unsafe(nil)); end

  # Hook method defining how an attribute value should be retrieved. By default
  # this is assumed to be an instance named after the attribute. Override this
  # method in subclasses should you need to retrieve the value for a given
  # attribute differently:
  #
  #   class MyClass
  #     include ActiveModel::Validations
  #
  #     def initialize(data = {})
  #       @data = data
  #     end
  #
  #     def read_attribute_for_validation(key)
  #       @data[key]
  #     end
  #   end
  def read_attribute_for_validation(*_arg0); end

  # Runs all the specified validations and returns +true+ if no errors were
  # added otherwise +false+.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name
  #   end
  #
  #   person = Person.new
  #   person.name = ''
  #   person.valid? # => false
  #   person.name = 'david'
  #   person.valid? # => true
  #
  # Context can optionally be supplied to define which callbacks to test
  # against (the context is defined on the validations using <tt>:on</tt>).
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name, on: :new
  #   end
  #
  #   person = Person.new
  #   person.valid?       # => true
  #   person.valid?(:new) # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:336
  def valid?(context = T.unsafe(nil)); end

  # Runs all the specified validations and returns +true+ if no errors were
  # added otherwise +false+.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name
  #   end
  #
  #   person = Person.new
  #   person.name = ''
  #   person.valid? # => false
  #   person.name = 'david'
  #   person.valid? # => true
  #
  # Context can optionally be supplied to define which callbacks to test
  # against (the context is defined on the validations using <tt>:on</tt>).
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates_presence_of :name, on: :new
  #   end
  #
  #   person = Person.new
  #   person.valid?       # => true
  #   person.valid?(:new) # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:336
  def validate(context = T.unsafe(nil)); end

  # Runs all the validations within the specified context. Returns +true+ if
  # no errors are found, raises +ValidationError+ otherwise.
  #
  # Validations with no <tt>:on</tt> option will run no matter the context. Validations with
  # some <tt>:on</tt> option will only run in the specified context.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:384
  def validate!(context = T.unsafe(nil)); end

  # Passes the record off to the class or classes specified and allows them
  # to add errors based on more complex conditions.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     validate :instance_validations
  #
  #     def instance_validations
  #       validates_with MyValidator
  #     end
  #   end
  #
  # Please consult the class method documentation for more information on
  # creating your own validator.
  #
  # You may also pass it multiple classes, like so:
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     validate :instance_validations, on: :create
  #
  #     def instance_validations
  #       validates_with MyValidator, MyOtherValidator
  #     end
  #   end
  #
  # Standard configuration options (<tt>:on</tt>, <tt>:if</tt> and
  # <tt>:unless</tt>), which are available on the class version of
  # +validates_with+, should instead be placed on the +validates+ method
  # as these are applied and tested in the callback.
  #
  # If you pass any additional configuration options, they will be passed
  # to the class and available as +options+, please refer to the
  # class version of this method for more information.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/with.rb:137
  def validates_with(*args, &block); end

  private

  # Clean the +Errors+ object if instance is duped.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:285
  def initialize_dup(other); end

  # @raise [ValidationError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:413
  def raise_validation_error; end

  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:408
  def run_validations!; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

# == \Active \Model Absence Validator
#
# source://activemodel-5.2.8.1/lib/active_model/validations/absence.rb:6
class ActiveModel::Validations::AbsenceValidator < ::ActiveModel::EachValidator
  # source://activemodel-5.2.8.1/lib/active_model/validations/absence.rb:7
  def validate_each(record, attr_name, value); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:5
class ActiveModel::Validations::AcceptanceValidator < ::ActiveModel::EachValidator
  # @return [AcceptanceValidator] a new instance of AcceptanceValidator
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:6
  def initialize(options); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:11
  def validate_each(record, attribute, value); end

  private

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:23
  def acceptable_option?(value); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:19
  def setup!(klass); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:44
class ActiveModel::Validations::AcceptanceValidator::AttributeDefinition
  # @return [AttributeDefinition] a new instance of AttributeDefinition
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:45
  def initialize(attributes); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:54
  def define_on(klass); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:49
  def matches?(method_name); end

  protected

  # Returns the value of attribute attributes.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:65
  def attributes; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:69
  def convert_to_reader_name(method_name); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:27
class ActiveModel::Validations::AcceptanceValidator::LazilyDefineAttributes < ::Module
  # @return [LazilyDefineAttributes] a new instance of LazilyDefineAttributes
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:28
  def initialize(attribute_definition); end
end

# == Active \Model \Validation \Callbacks
#
# Provides an interface for any class to have +before_validation+ and
# +after_validation+ callbacks.
#
# First, include ActiveModel::Validations::Callbacks from the class you are
# creating:
#
#   class MyModel
#     include ActiveModel::Validations::Callbacks
#
#     before_validation :do_stuff_before_validation
#     after_validation  :do_stuff_after_validation
#   end
#
# Like other <tt>before_*</tt> callbacks if +before_validation+ throws
# +:abort+ then <tt>valid?</tt> will not be called.
#
# source://activemodel-5.2.8.1/lib/active_model/validations/callbacks.rb:22
module ActiveModel::Validations::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker

  private

  # Overwrite run validations to include callbacks.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/callbacks.rb:117
  def run_validations!; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/callbacks.rb:32
module ActiveModel::Validations::Callbacks::ClassMethods
  # Defines a callback that will get called right after validation.
  #
  #   class Person
  #     include ActiveModel::Validations
  #     include ActiveModel::Validations::Callbacks
  #
  #     attr_accessor :name, :status
  #
  #     validates_presence_of :name
  #
  #     after_validation :set_status
  #
  #     private
  #
  #     def set_status
  #       self.status = errors.empty?
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name = ''
  #   person.valid? # => false
  #   person.status # => false
  #   person.name = 'bob'
  #   person.valid? # => true
  #   person.status # => true
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/callbacks.rb:97
  def after_validation(*args, &block); end

  # Defines a callback that will get called right before validation.
  #
  #   class Person
  #     include ActiveModel::Validations
  #     include ActiveModel::Validations::Callbacks
  #
  #     attr_accessor :name
  #
  #     validates_length_of :name, maximum: 6
  #
  #     before_validation :remove_whitespaces
  #
  #     private
  #
  #     def remove_whitespaces
  #       name.strip!
  #     end
  #   end
  #
  #   person = Person.new
  #   person.name = '  bob  '
  #   person.valid? # => true
  #   person.name   # => "bob"
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/callbacks.rb:56
  def before_validation(*args, &block); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations.rb:57
module ActiveModel::Validations::ClassMethods
  # Returns +true+ if +attribute+ is an attribute method, +false+ otherwise.
  #
  #  class Person
  #    include ActiveModel::Validations
  #
  #    attr_accessor :name
  #  end
  #
  #  User.attribute_method?(:name) # => true
  #  User.attribute_method?(:age)  # => false
  #
  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:272
  def attribute_method?(attribute); end

  # Clears all of the validators and validations.
  #
  # Note that this will clear anything that is being used to validate
  # the model for both the +validates_with+ and +validate+ methods.
  # It clears the validators that are created with an invocation of
  # +validates_with+ and the callbacks that are set by an invocation
  # of +validate+.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     validates_with MyValidator
  #     validates_with OtherValidator, on: :create
  #     validates_with StrictValidator, strict: true
  #     validate :cannot_be_robot
  #
  #     def cannot_be_robot
  #       errors.add(:base, 'A person cannot be a robot') if person_is_robot
  #     end
  #   end
  #
  #   Person.validators
  #   # => [
  #   #      #<MyValidator:0x007fbff403e808 @options={}>,
  #   #      #<OtherValidator:0x007fbff403d930 @options={on: :create}>,
  #   #      #<StrictValidator:0x007fbff3204a30 @options={strict:true}>
  #   #    ]
  #
  # If one runs <tt>Person.clear_validators!</tt> and then checks to see what
  # validators this class has, you would obtain:
  #
  #   Person.validators # => []
  #
  # Also, the callback set by <tt>validate :cannot_be_robot</tt> will be erased
  # so that:
  #
  #   Person._validate_callbacks.empty?  # => true
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:236
  def clear_validators!; end

  # Copy validators on inheritance.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:277
  def inherited(base); end

  # Adds a validation method or block to the class. This is useful when
  # overriding the +validate+ instance method becomes too unwieldy and
  # you're looking for more descriptive declaration of your validations.
  #
  # This can be done with a symbol pointing to a method:
  #
  #   class Comment
  #     include ActiveModel::Validations
  #
  #     validate :must_be_friends
  #
  #     def must_be_friends
  #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
  #     end
  #   end
  #
  # With a block which is passed with the current record to be validated:
  #
  #   class Comment
  #     include ActiveModel::Validations
  #
  #     validate do |comment|
  #       comment.must_be_friends
  #     end
  #
  #     def must_be_friends
  #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
  #     end
  #   end
  #
  # Or with a block where self points to the current record to be validated:
  #
  #   class Comment
  #     include ActiveModel::Validations
  #
  #     validate do
  #       errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee)
  #     end
  #   end
  #
  # Note that the return value of validation methods is not relevant.
  # It's not possible to halt the validate callback chain.
  #
  # Options:
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default +nil+. You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to
  #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc or string should return or evaluate to a +true+ or +false+
  #   value.
  #
  # NOTE: Calling +validate+ multiple times on the same method will overwrite previous definitions.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:154
  def validate(*args, &block); end

  # This method is a shortcut to all default validators and any custom
  # validator classes ending in 'Validator'. Note that Rails default
  # validators can be overridden inside specific classes by creating
  # custom validator classes in their place such as PresenceValidator.
  #
  # Examples of using the default rails validators:
  #
  #   validates :terms, acceptance: true
  #   validates :password, confirmation: true
  #   validates :username, exclusion: { in: %w(admin superuser) }
  #   validates :email, format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i, on: :create }
  #   validates :age, inclusion: { in: 0..9 }
  #   validates :first_name, length: { maximum: 30 }
  #   validates :age, numericality: true
  #   validates :username, presence: true
  #
  # The power of the +validates+ method comes when using custom validators
  # and default validators in one call for a given attribute.
  #
  #   class EmailValidator < ActiveModel::EachValidator
  #     def validate_each(record, attribute, value)
  #       record.errors.add attribute, (options[:message] || "is not an email") unless
  #         value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
  #     end
  #   end
  #
  #   class Person
  #     include ActiveModel::Validations
  #     attr_accessor :name, :email
  #
  #     validates :name, presence: true, length: { maximum: 100 }
  #     validates :email, presence: true, email: true
  #   end
  #
  # Validator classes may also exist within the class being validated
  # allowing custom modules of validators to be included as needed.
  #
  #   class Film
  #     include ActiveModel::Validations
  #
  #     class TitleValidator < ActiveModel::EachValidator
  #       def validate_each(record, attribute, value)
  #         record.errors.add attribute, "must start with 'the'" unless value =~ /\Athe/i
  #       end
  #     end
  #
  #     validates :name, title: true
  #   end
  #
  # Additionally validator classes may be in another namespace and still
  # used within any class.
  #
  #   validates :name, :'film/title' => true
  #
  # The validators hash can also handle regular expressions, ranges, arrays
  # and strings in shortcut form.
  #
  #   validates :email, format: /@/
  #   validates :gender, inclusion: %w(male female)
  #   validates :password, length: 6..20
  #
  # When using shortcut form, ranges and arrays are passed to your
  # validator's initializer as <tt>options[:in]</tt> while other types
  # including regular expressions and strings are passed as <tt>options[:with]</tt>.
  #
  # There is also a list of options that could be used along with validators:
  #
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default +nil+. You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc or string should return or evaluate to a +true+ or
  #   +false+ value.
  # * <tt>:allow_nil</tt> - Skip validation if the attribute is +nil+.
  # * <tt>:allow_blank</tt> - Skip validation if the attribute is blank.
  # * <tt>:strict</tt> - If the <tt>:strict</tt> option is set to true
  #   will raise ActiveModel::StrictValidationFailed instead of adding the error.
  #   <tt>:strict</tt> option can also be set to any other exception.
  #
  # Example:
  #
  #   validates :password, presence: true, confirmation: true, if: :password_required?
  #   validates :token, length: 24, strict: TokenLengthException
  #
  #
  # Finally, the options +:if+, +:unless+, +:on+, +:allow_blank+, +:allow_nil+, +:strict+
  # and +:message+ can be given to one specific validator, as a hash:
  #
  #   validates :password, presence: { if: :password_required?, message: 'is forgotten.' }, confirmation: true
  #
  # @raise [ArgumentError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/validates.rb:105
  def validates(*attributes); end

  # This method is used to define validations that cannot be corrected by end
  # users and are considered exceptional. So each validator defined with bang
  # or <tt>:strict</tt> option set to <tt>true</tt> will always raise
  # <tt>ActiveModel::StrictValidationFailed</tt> instead of adding error
  # when validation fails. See <tt>validates</tt> for more information about
  # the validation itself.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name
  #     validates! :name, presence: true
  #   end
  #
  #   person = Person.new
  #   person.name = ''
  #   person.valid?
  #   # => ActiveModel::StrictValidationFailed: Name can't be blank
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/validates.rb:146
  def validates!(*attributes); end

  # Validates each attribute against a block.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :first_name, :last_name
  #
  #     validates_each :first_name, :last_name, allow_blank: true do |record, attr, value|
  #       record.errors.add attr, 'starts with z.' if value.to_s[0] == ?z
  #     end
  #   end
  #
  # Options:
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default +nil+. You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.
  # * <tt>:allow_blank</tt> - Skip validation if attribute is blank.
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to
  #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc or string should return or evaluate to a +true+ or +false+
  #   value.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:87
  def validates_each(*attr_names, &block); end

  # source://validate_url-1.0.15/lib/validate_url.rb:85
  def validates_url(*attr_names); end

  # Passes the record off to the class or classes specified and allows them
  # to add errors based on more complex conditions.
  #
  #   class Person
  #     include ActiveModel::Validations
  #     validates_with MyValidator
  #   end
  #
  #   class MyValidator < ActiveModel::Validator
  #     def validate(record)
  #       if some_complex_logic
  #         record.errors.add :base, 'This record is invalid'
  #       end
  #     end
  #
  #     private
  #       def some_complex_logic
  #         # ...
  #       end
  #   end
  #
  # You may also pass it multiple classes, like so:
  #
  #   class Person
  #     include ActiveModel::Validations
  #     validates_with MyValidator, MyOtherValidator, on: :create
  #   end
  #
  # Configuration options:
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default +nil+. You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>).
  #   The method, proc or string should return or evaluate to a +true+ or
  #   +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to
  #   determine if the validation should not occur
  #   (e.g. <tt>unless: :skip_validation</tt>, or
  #   <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>).
  #   The method, proc or string should return or evaluate to a +true+ or
  #   +false+ value.
  # * <tt>:strict</tt> - Specifies whether validation should be strict.
  #   See <tt>ActiveModel::Validations#validates!</tt> for more information.
  #
  # If you pass any additional configuration options, they will be passed
  # to the class and available as +options+:
  #
  #   class Person
  #     include ActiveModel::Validations
  #     validates_with MyValidator, my_custom_key: 'my custom value'
  #   end
  #
  #   class MyValidator < ActiveModel::Validator
  #     def validate(record)
  #       options[:my_custom_key] # => "my custom value"
  #     end
  #   end
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/with.rb:81
  def validates_with(*args, &block); end

  # List all validators that are being used to validate the model using
  # +validates_with+ method.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     validates_with MyValidator
  #     validates_with OtherValidator, on: :create
  #     validates_with StrictValidator, strict: true
  #   end
  #
  #   Person.validators
  #   # => [
  #   #      #<MyValidator:0x007fbff403e808 @options={}>,
  #   #      #<OtherValidator:0x007fbff403d930 @options={on: :create}>,
  #   #      #<StrictValidator:0x007fbff3204a30 @options={strict:true}>
  #   #    ]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:194
  def validators; end

  # List all validators that are being used to validate a specific attribute.
  #
  #   class Person
  #     include ActiveModel::Validations
  #
  #     attr_accessor :name , :age
  #
  #     validates_presence_of :name
  #     validates_inclusion_of :age, in: 0..99
  #   end
  #
  #   Person.validators_on(:name)
  #   # => [
  #   #       #<ActiveModel::Validations::PresenceValidator:0x007fe604914e60 @attributes=[:name], @options={}>,
  #   #    ]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations.rb:256
  def validators_on(*attributes); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/validations/validates.rb:160
  def _parse_validates_options(options); end

  # When creating custom validators, it might be useful to be able to specify
  # additional default keys. This can be done by overwriting this method.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/validates.rb:156
  def _validates_default_keys; end
end

# source://activemodel-5.2.8.1/lib/active_model/validations.rb:91
ActiveModel::Validations::ClassMethods::VALID_OPTIONS_FOR_VALIDATE = T.let(T.unsafe(nil), Array)

# source://activemodel-5.2.8.1/lib/active_model/validations/clusivity.rb:7
module ActiveModel::Validations::Clusivity
  # source://activemodel-5.2.8.1/lib/active_model/validations/clusivity.rb:11
  def check_validity!; end

  private

  # source://activemodel-5.2.8.1/lib/active_model/validations/clusivity.rb:31
  def delimiter; end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/clusivity.rb:19
  def include?(record, value); end

  # In Ruby 2.2 <tt>Range#include?</tt> on non-number-or-time-ish ranges checks all
  # possible values in the range for equality, which is slower but more accurate.
  # <tt>Range#cover?</tt> uses the previous logic of comparing a value with the range
  # endpoints, which is fast but is only accurate on Numeric, Time, Date,
  # or DateTime ranges.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/clusivity.rb:40
  def inclusion_method(enumerable); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/clusivity.rb:8
ActiveModel::Validations::Clusivity::ERROR_MESSAGE = T.let(T.unsafe(nil), String)

# source://activemodel-5.2.8.1/lib/active_model/validations/confirmation.rb:5
class ActiveModel::Validations::ConfirmationValidator < ::ActiveModel::EachValidator
  # @return [ConfirmationValidator] a new instance of ConfirmationValidator
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/confirmation.rb:6
  def initialize(options); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/confirmation.rb:11
  def validate_each(record, attribute, value); end

  private

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/confirmation.rb:31
  def confirmation_value_equal?(record, attribute, value, confirmed); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/confirmation.rb:21
  def setup!(klass); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/exclusion.rb:7
class ActiveModel::Validations::ExclusionValidator < ::ActiveModel::EachValidator
  include ::ActiveModel::Validations::Clusivity

  # source://activemodel-5.2.8.1/lib/active_model/validations/exclusion.rb:10
  def validate_each(record, attribute, value); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/format.rb:5
class ActiveModel::Validations::FormatValidator < ::ActiveModel::EachValidator
  # source://activemodel-5.2.8.1/lib/active_model/validations/format.rb:16
  def check_validity!; end

  # source://activemodel-5.2.8.1/lib/active_model/validations/format.rb:6
  def validate_each(record, attribute, value); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/validations/format.rb:36
  def check_options_validity(name); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/format.rb:27
  def option_call(record, name); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/format.rb:32
  def record_error(record, attribute, name, value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/format.rb:50
  def regexp_using_multiline_anchors?(regexp); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/inclusion.rb:17
module ActiveModel::Validations::HelperMethods
  # Validates that the specified attributes are blank (as defined by
  # Object#blank?). Happens by default on save.
  #
  #   class Person < ActiveRecord::Base
  #     validates_absence_of :first_name
  #   end
  #
  # The first_name attribute must be in the object and it must be blank.
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "must be blank").
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/absence.rb:28
  def validates_absence_of(*attr_names); end

  # Encapsulates the pattern of wanting to validate the acceptance of a
  # terms of service check box (or similar agreement).
  #
  #   class Person < ActiveRecord::Base
  #     validates_acceptance_of :terms_of_service
  #     validates_acceptance_of :eula, message: 'must be abided'
  #   end
  #
  # If the database column does not exist, the +terms_of_service+ attribute
  # is entirely virtual. This check is performed only if +terms_of_service+
  # is not +nil+ and by default on save.
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "must be
  #   accepted").
  # * <tt>:accept</tt> - Specifies a value that is considered accepted.
  #   Also accepts an array of possible values. The default value is
  #   an array ["1", true], which makes it easy to relate to an HTML
  #   checkbox. This should be set to, or include, +true+ if you are validating
  #   a database column, since the attribute is typecast from "1" to +true+
  #   before validation.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/acceptance.rb:101
  def validates_acceptance_of(*attr_names); end

  # Encapsulates the pattern of wanting to validate a password or email
  # address field with a confirmation.
  #
  #   Model:
  #     class Person < ActiveRecord::Base
  #       validates_confirmation_of :user_name, :password
  #       validates_confirmation_of :email_address,
  #                                 message: 'should match confirmation'
  #     end
  #
  #   View:
  #     <%= password_field "person", "password" %>
  #     <%= password_field "person", "password_confirmation" %>
  #
  # The added +password_confirmation+ attribute is virtual; it exists only
  # as an in-memory attribute for validating the password. To achieve this,
  # the validation adds accessors to the model for the confirmation
  # attribute.
  #
  # NOTE: This check is performed only if +password_confirmation+ is not
  # +nil+. To require confirmation, make sure to add a presence check for
  # the confirmation attribute:
  #
  #   validates_presence_of :password_confirmation, if: :password_changed?
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "doesn't match
  #   <tt>%{translated_attribute_name}</tt>").
  # * <tt>:case_sensitive</tt> - Looks for an exact match. Ignored by
  #   non-text columns (+true+ by default).
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/confirmation.rb:75
  def validates_confirmation_of(*attr_names); end

  # Validates that the value of the specified attribute is not in a
  # particular enumerable object.
  #
  #   class Person < ActiveRecord::Base
  #     validates_exclusion_of :username, in: %w( admin superuser ), message: "You don't belong here"
  #     validates_exclusion_of :age, in: 30..60, message: 'This site is only for under 30 and over 60'
  #     validates_exclusion_of :format, in: %w( mov avi ), message: "extension %{value} is not allowed"
  #     validates_exclusion_of :password, in: ->(person) { [person.username, person.first_name] },
  #                            message: 'should not be the same as your username or first name'
  #     validates_exclusion_of :karma, in: :reserved_karmas
  #   end
  #
  # Configuration options:
  # * <tt>:in</tt> - An enumerable object of items that the value shouldn't
  #   be part of. This can be supplied as a proc, lambda or symbol which returns an
  #   enumerable. If the enumerable is a numerical, time or datetime range the test
  #   is performed with <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. When
  #   using a proc or lambda the instance under validation is passed as an argument.
  # * <tt>:within</tt> - A synonym(or alias) for <tt>:in</tt>
  #   <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>.
  # * <tt>:message</tt> - Specifies a custom error message (default is: "is
  #   reserved").
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/exclusion.rb:44
  def validates_exclusion_of(*attr_names); end

  # Validates whether the value of the specified attribute is of the correct
  # form, going by the regular expression provided. You can require that the
  # attribute matches the regular expression:
  #
  #   class Person < ActiveRecord::Base
  #     validates_format_of :email, with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i, on: :create
  #   end
  #
  # Alternatively, you can require that the specified attribute does _not_
  # match the regular expression:
  #
  #   class Person < ActiveRecord::Base
  #     validates_format_of :email, without: /NOSPAM/
  #   end
  #
  # You can also provide a proc or lambda which will determine the regular
  # expression that will be used to validate the attribute.
  #
  #   class Person < ActiveRecord::Base
  #     # Admin can have number as a first letter in their screen name
  #     validates_format_of :screen_name,
  #                         with: ->(person) { person.admin? ? /\A[a-z0-9][a-z0-9_\-]*\z/i : /\A[a-z][a-z0-9_\-]*\z/i }
  #   end
  #
  # Note: use <tt>\A</tt> and <tt>\z</tt> to match the start and end of the
  # string, <tt>^</tt> and <tt>$</tt> match the start/end of a line.
  #
  # Due to frequent misuse of <tt>^</tt> and <tt>$</tt>, you need to pass
  # the <tt>multiline: true</tt> option in case you use any of these two
  # anchors in the provided regular expression. In most cases, you should be
  # using <tt>\A</tt> and <tt>\z</tt>.
  #
  # You must pass either <tt>:with</tt> or <tt>:without</tt> as an option.
  # In addition, both must be a regular expression or a proc or lambda, or
  # else an exception will be raised.
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "is invalid").
  # * <tt>:with</tt> - Regular expression that if the attribute matches will
  #   result in a successful validation. This can be provided as a proc or
  #   lambda returning regular expression which will be called at runtime.
  # * <tt>:without</tt> - Regular expression that if the attribute does not
  #   match will result in a successful validation. This can be provided as
  #   a proc or lambda returning regular expression which will be called at
  #   runtime.
  # * <tt>:multiline</tt> - Set to true if your regular expression contains
  #   anchors that match the beginning or end of lines as opposed to the
  #   beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/format.rb:109
  def validates_format_of(*attr_names); end

  # Validates whether the value of the specified attribute is available in a
  # particular enumerable object.
  #
  #   class Person < ActiveRecord::Base
  #     validates_inclusion_of :gender, in: %w( m f )
  #     validates_inclusion_of :age, in: 0..99
  #     validates_inclusion_of :format, in: %w( jpg gif png ), message: "extension %{value} is not included in the list"
  #     validates_inclusion_of :states, in: ->(person) { STATES[person.country] }
  #     validates_inclusion_of :karma, in: :available_karmas
  #   end
  #
  # Configuration options:
  # * <tt>:in</tt> - An enumerable object of available items. This can be
  #   supplied as a proc, lambda or symbol which returns an enumerable. If the
  #   enumerable is a numerical, time or datetime range the test is performed
  #   with <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. When using
  #   a proc or lambda the instance under validation is passed as an argument.
  # * <tt>:within</tt> - A synonym(or alias) for <tt>:in</tt>
  # * <tt>:message</tt> - Specifies a custom error message (default is: "is
  #   not included in the list").
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/inclusion.rb:42
  def validates_inclusion_of(*attr_names); end

  # Validates that the specified attributes match the length restrictions
  # supplied. Only one constraint option can be used at a time apart from
  # +:minimum+ and +:maximum+ that can be combined together:
  #
  #   class Person < ActiveRecord::Base
  #     validates_length_of :first_name, maximum: 30
  #     validates_length_of :last_name, maximum: 30, message: "less than 30 if you don't mind"
  #     validates_length_of :fax, in: 7..32, allow_nil: true
  #     validates_length_of :phone, in: 7..32, allow_blank: true
  #     validates_length_of :user_name, within: 6..20, too_long: 'pick a shorter name', too_short: 'pick a longer name'
  #     validates_length_of :zip_code, minimum: 5, too_short: 'please enter at least 5 characters'
  #     validates_length_of :smurf_leader, is: 4, message: "papa is spelled with 4 characters... don't play me."
  #     validates_length_of :words_in_essay, minimum: 100, too_short: 'Your essay must be at least 100 words.'
  #
  #     private
  #
  #     def words_in_essay
  #       essay.scan(/\w+/)
  #     end
  #   end
  #
  # Constraint options:
  #
  # * <tt>:minimum</tt> - The minimum size of the attribute.
  # * <tt>:maximum</tt> - The maximum size of the attribute. Allows +nil+ by
  #   default if not used with +:minimum+.
  # * <tt>:is</tt> - The exact size of the attribute.
  # * <tt>:within</tt> - A range specifying the minimum and maximum size of
  #   the attribute.
  # * <tt>:in</tt> - A synonym (or alias) for <tt>:within</tt>.
  #
  # Other options:
  #
  # * <tt>:allow_nil</tt> - Attribute may be +nil+; skip validation.
  # * <tt>:allow_blank</tt> - Attribute may be blank; skip validation.
  # * <tt>:too_long</tt> - The error message if the attribute goes over the
  #   maximum (default is: "is too long (maximum is %{count} characters)").
  # * <tt>:too_short</tt> - The error message if the attribute goes under the
  #   minimum (default is: "is too short (minimum is %{count} characters)").
  # * <tt>:wrong_length</tt> - The error message if using the <tt>:is</tt>
  #   method and the attribute is the wrong size (default is: "is the wrong
  #   length (should be %{count} characters)").
  # * <tt>:message</tt> - The error message to use for a <tt>:minimum</tt>,
  #   <tt>:maximum</tt>, or <tt>:is</tt> violation. An alias of the appropriate
  #   <tt>too_long</tt>/<tt>too_short</tt>/<tt>wrong_length</tt> message.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+ and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:122
  def validates_length_of(*attr_names); end

  # Validates whether the value of the specified attribute is numeric by
  # trying to convert it to a float with Kernel.Float (if <tt>only_integer</tt>
  # is +false+) or applying it to the regular expression <tt>/\A[\+\-]?\d+\z/</tt>
  # (if <tt>only_integer</tt> is set to +true+).
  #
  #   class Person < ActiveRecord::Base
  #     validates_numericality_of :value, on: :create
  #   end
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "is not a number").
  # * <tt>:only_integer</tt> - Specifies whether the value has to be an
  #   integer, e.g. an integral value (default is +false+).
  # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+ (default is
  #   +false+). Notice that for Integer and Float columns empty strings are
  #   converted to +nil+.
  # * <tt>:greater_than</tt> - Specifies the value must be greater than the
  #   supplied value.
  # * <tt>:greater_than_or_equal_to</tt> - Specifies the value must be
  #   greater than or equal the supplied value.
  # * <tt>:equal_to</tt> - Specifies the value must be equal to the supplied
  #   value.
  # * <tt>:less_than</tt> - Specifies the value must be less than the
  #   supplied value.
  # * <tt>:less_than_or_equal_to</tt> - Specifies the value must be less
  #   than or equal the supplied value.
  # * <tt>:other_than</tt> - Specifies the value must be other than the
  #   supplied value.
  # * <tt>:odd</tt> - Specifies the value must be an odd number.
  # * <tt>:even</tt> - Specifies the value must be an even number.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+ .
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # The following checks can also be supplied with a proc or a symbol which
  # corresponds to a method:
  #
  # * <tt>:greater_than</tt>
  # * <tt>:greater_than_or_equal_to</tt>
  # * <tt>:equal_to</tt>
  # * <tt>:less_than</tt>
  # * <tt>:less_than_or_equal_to</tt>
  # * <tt>:only_integer</tt>
  #
  # For example:
  #
  #   class Person < ActiveRecord::Base
  #     validates_numericality_of :width, less_than: ->(person) { person.height }
  #     validates_numericality_of :width, greater_than: :minimum_weight
  #   end
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:184
  def validates_numericality_of(*attr_names); end

  # Validates that the specified attributes are not blank (as defined by
  # Object#blank?). Happens by default on save.
  #
  #   class Person < ActiveRecord::Base
  #     validates_presence_of :first_name
  #   end
  #
  # The first_name attribute must be in the object and it cannot be blank.
  #
  # If you want to validate the presence of a boolean field (where the real
  # values are +true+ and +false+), you will want to use
  # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
  #
  # This is due to the way Object#blank? handles boolean values:
  # <tt>false.blank? # => true</tt>.
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/presence.rb:34
  def validates_presence_of(*attr_names); end

  # Validates that the specified attributes match the length restrictions
  # supplied. Only one constraint option can be used at a time apart from
  # +:minimum+ and +:maximum+ that can be combined together:
  #
  #   class Person < ActiveRecord::Base
  #     validates_length_of :first_name, maximum: 30
  #     validates_length_of :last_name, maximum: 30, message: "less than 30 if you don't mind"
  #     validates_length_of :fax, in: 7..32, allow_nil: true
  #     validates_length_of :phone, in: 7..32, allow_blank: true
  #     validates_length_of :user_name, within: 6..20, too_long: 'pick a shorter name', too_short: 'pick a longer name'
  #     validates_length_of :zip_code, minimum: 5, too_short: 'please enter at least 5 characters'
  #     validates_length_of :smurf_leader, is: 4, message: "papa is spelled with 4 characters... don't play me."
  #     validates_length_of :words_in_essay, minimum: 100, too_short: 'Your essay must be at least 100 words.'
  #
  #     private
  #
  #     def words_in_essay
  #       essay.scan(/\w+/)
  #     end
  #   end
  #
  # Constraint options:
  #
  # * <tt>:minimum</tt> - The minimum size of the attribute.
  # * <tt>:maximum</tt> - The maximum size of the attribute. Allows +nil+ by
  #   default if not used with +:minimum+.
  # * <tt>:is</tt> - The exact size of the attribute.
  # * <tt>:within</tt> - A range specifying the minimum and maximum size of
  #   the attribute.
  # * <tt>:in</tt> - A synonym (or alias) for <tt>:within</tt>.
  #
  # Other options:
  #
  # * <tt>:allow_nil</tt> - Attribute may be +nil+; skip validation.
  # * <tt>:allow_blank</tt> - Attribute may be blank; skip validation.
  # * <tt>:too_long</tt> - The error message if the attribute goes over the
  #   maximum (default is: "is too long (maximum is %{count} characters)").
  # * <tt>:too_short</tt> - The error message if the attribute goes under the
  #   minimum (default is: "is too short (minimum is %{count} characters)").
  # * <tt>:wrong_length</tt> - The error message if using the <tt>:is</tt>
  #   method and the attribute is the wrong size (default is: "is the wrong
  #   length (should be %{count} characters)").
  # * <tt>:message</tt> - The error message to use for a <tt>:minimum</tt>,
  #   <tt>:maximum</tt>, or <tt>:is</tt> violation. An alias of the appropriate
  #   <tt>too_long</tt>/<tt>too_short</tt>/<tt>wrong_length</tt> message.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+ and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:122
  def validates_size_of(*attr_names); end

  private

  # source://activemodel-5.2.8.1/lib/active_model/validations/helper_methods.rb:7
  def _merge_attributes(attr_names); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/inclusion.rb:7
class ActiveModel::Validations::InclusionValidator < ::ActiveModel::EachValidator
  include ::ActiveModel::Validations::Clusivity

  # source://activemodel-5.2.8.1/lib/active_model/validations/inclusion.rb:10
  def validate_each(record, attribute, value); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:5
class ActiveModel::Validations::LengthValidator < ::ActiveModel::EachValidator
  # @return [LengthValidator] a new instance of LengthValidator
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:11
  def initialize(options); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:24
  def check_validity!; end

  # source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:40
  def validate_each(record, attribute, value); end

  private

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:67
  def skip_nil_check?(key); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:7
ActiveModel::Validations::LengthValidator::CHECKS = T.let(T.unsafe(nil), Hash)

# source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:6
ActiveModel::Validations::LengthValidator::MESSAGES = T.let(T.unsafe(nil), Hash)

# source://activemodel-5.2.8.1/lib/active_model/validations/length.rb:9
ActiveModel::Validations::LengthValidator::RESERVED_OPTIONS = T.let(T.unsafe(nil), Array)

# source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:7
class ActiveModel::Validations::NumericalityValidator < ::ActiveModel::EachValidator
  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:16
  def check_validity!; end

  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:25
  def validate_each(record, attr_name, value); end

  private

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:115
  def allow_only_integer?(record); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:109
  def filtered_options(value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:105
  def is_hexadecimal_literal?(raw_value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:101
  def is_integer?(raw_value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:83
  def is_number?(raw_value); end

  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:89
  def parse_as_number(raw_value); end

  # @return [Boolean]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:126
  def record_attribute_changed_in_place?(record, attr_name); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:8
ActiveModel::Validations::NumericalityValidator::CHECKS = T.let(T.unsafe(nil), Hash)

# source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:14
ActiveModel::Validations::NumericalityValidator::INTEGER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://activemodel-5.2.8.1/lib/active_model/validations/numericality.rb:12
ActiveModel::Validations::NumericalityValidator::RESERVED_OPTIONS = T.let(T.unsafe(nil), Array)

# source://activemodel-5.2.8.1/lib/active_model/validations/presence.rb:5
class ActiveModel::Validations::PresenceValidator < ::ActiveModel::EachValidator
  # source://activemodel-5.2.8.1/lib/active_model/validations/presence.rb:6
  def validate_each(record, attr_name, value); end
end

# source://activemodel-5.2.8.1/lib/active_model/validations/with.rb:7
class ActiveModel::Validations::WithValidator < ::ActiveModel::EachValidator
  # source://activemodel-5.2.8.1/lib/active_model/validations/with.rb:8
  def validate_each(record, attr, val); end
end

# == Active \Model \Validator
#
# A simple base class that can be used along with
# ActiveModel::Validations::ClassMethods.validates_with
#
#   class Person
#     include ActiveModel::Validations
#     validates_with MyValidator
#   end
#
#   class MyValidator < ActiveModel::Validator
#     def validate(record)
#       if some_complex_logic
#         record.errors.add(:base, "This record is invalid")
#       end
#     end
#
#     private
#       def some_complex_logic
#         # ...
#       end
#   end
#
# Any class that inherits from ActiveModel::Validator must implement a method
# called +validate+ which accepts a +record+.
#
#   class Person
#     include ActiveModel::Validations
#     validates_with MyValidator
#   end
#
#   class MyValidator < ActiveModel::Validator
#     def validate(record)
#       record # => The person instance being validated
#       options # => Any non-standard options passed to validates_with
#     end
#   end
#
# To cause a validation error, you must add to the +record+'s errors directly
# from within the validators message.
#
#   class MyValidator < ActiveModel::Validator
#     def validate(record)
#       record.errors.add :base, "This is some custom error message"
#       record.errors.add :first_name, "This is some complex validation"
#       # etc...
#     end
#   end
#
# To add behavior to the initialize method, use the following signature:
#
#   class MyValidator < ActiveModel::Validator
#     def initialize(options)
#       super
#       @my_custom_field = options[:field_name] || :first_name
#     end
#   end
#
# Note that the validator is initialized only once for the whole application
# life cycle, and not on each validation run.
#
# The easiest way to add custom validators for validating individual attributes
# is with the convenient <tt>ActiveModel::EachValidator</tt>.
#
#   class TitleValidator < ActiveModel::EachValidator
#     def validate_each(record, attribute, value)
#       record.errors.add attribute, 'must be Mr., Mrs., or Dr.' unless %w(Mr. Mrs. Dr.).include?(value)
#     end
#   end
#
# This can now be used in combination with the +validates+ method
# (see <tt>ActiveModel::Validations::ClassMethods.validates</tt> for more on this).
#
#   class Person
#     include ActiveModel::Validations
#     attr_accessor :title
#
#     validates :title, presence: true, title: true
#   end
#
# It can be useful to access the class that is using that validator when there are prerequisites such
# as an +attr_accessor+ being present. This class is accessible via <tt>options[:class]</tt> in the constructor.
# To setup your validator override the constructor.
#
#   class MyValidator < ActiveModel::Validator
#     def initialize(options={})
#       super
#       options[:class].send :attr_accessor, :custom_attribute
#     end
#   end
#
# source://activemodel-5.2.8.1/lib/active_model/validator.rb:96
class ActiveModel::Validator
  # Accepts options that will be made available through the +options+ reader.
  #
  # @return [Validator] a new instance of Validator
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:108
  def initialize(options = T.unsafe(nil)); end

  # Returns the kind for this validator.
  #
  #   PresenceValidator.new(attributes: [:username]).kind # => :presence
  #   AcceptanceValidator.new(attributes: [:terms]).kind  # => :acceptance
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:116
  def kind; end

  # Returns the value of attribute options.
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:97
  def options; end

  # Override this method in subclasses with validation logic, adding errors
  # to the records +errors+ array where necessary.
  #
  # @raise [NotImplementedError]
  #
  # source://activemodel-5.2.8.1/lib/active_model/validator.rb:122
  def validate(record); end

  class << self
    # Returns the kind of the validator.
    #
    #   PresenceValidator.kind   # => :presence
    #   AcceptanceValidator.kind # => :acceptance
    #
    # source://activemodel-5.2.8.1/lib/active_model/validator.rb:103
    def kind; end
  end
end
