# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `bigdecimal` gem.
# Please instead update this file by running `bin/tapioca gem bigdecimal`.

# source://bigdecimal-3.3.1/lib/bigdecimal.rb:13
class BigDecimal < ::Numeric
  # call-seq:
  #    self ** other -> bigdecimal
  #
  #  Returns the \BigDecimal value of +self+ raised to power +other+:
  #
  #    b = BigDecimal('3.14')
  #    b ** 2              # => 0.98596e1
  #    b ** 2.0            # => 0.98596e1
  #    b ** Rational(2, 1) # => 0.98596e1
  #
  #  Related: BigDecimal#power.
  #
  # source://bigdecimal-3.3.1/lib/bigdecimal.rb:77
  def **(y); end

  # call-seq:
  #   power(n)
  #   power(n, prec)
  #
  # Returns the value raised to the power of n.
  #
  # Also available as the operator **.
  #
  # source://bigdecimal-3.3.1/lib/bigdecimal.rb:97
  def power(y, prec = T.unsafe(nil)); end

  # Returns the square root of the value.
  #
  # Result has at least prec significant digits.
  #
  # @raise [FloatDomainError]
  #
  # source://bigdecimal-3.3.1/lib/bigdecimal.rb:211
  def sqrt(prec); end

  # call-seq:
  #     a.to_d -> bigdecimal
  #
  # Returns self.
  #
  #     require 'bigdecimal/util'
  #
  #     d = BigDecimal("3.14")
  #     d.to_d                       # => 0.314e1
  #
  # source://bigdecimal-3.3.1/lib/bigdecimal/util.rb:110
  def to_d; end

  # call-seq:
  #     a.to_digits -> string
  #
  # Converts a BigDecimal to a String of the form "nnnnnn.mmm".
  # This method is deprecated; use BigDecimal#to_s("F") instead.
  #
  #     require 'bigdecimal/util'
  #
  #     d = BigDecimal("3.14")
  #     d.to_digits                  # => "3.14"
  #
  # source://bigdecimal-3.3.1/lib/bigdecimal/util.rb:90
  def to_digits; end
end

BigDecimal::EXCEPTION_NaN = T.let(T.unsafe(nil), Integer)

# source://bigdecimal-3.3.1/lib/bigdecimal.rb:14
module BigDecimal::Internal
  class << self
    # Coerce x to BigDecimal with the specified precision.
    # TODO: some methods (example: BigMath.exp) require more precision than specified to coerce.
    #
    # @raise [ArgumentError]
    #
    # source://bigdecimal-3.3.1/lib/bigdecimal.rb:18
    def coerce_to_bigdecimal(x, prec, method_name); end

    # source://bigdecimal-3.3.1/lib/bigdecimal.rb:30
    def coerce_validate_prec(prec, method_name, accept_zero: T.unsafe(nil)); end

    # source://bigdecimal-3.3.1/lib/bigdecimal.rb:50
    def infinity_computation_result; end

    # source://bigdecimal-3.3.1/lib/bigdecimal.rb:57
    def nan_computation_result; end
  end
end

BigDecimal::VERSION = T.let(T.unsafe(nil), String)

# Core BigMath methods for BigDecimal (log, exp) are defined here.
# Other methods (sin, cos, atan) are defined in 'bigdecimal/math.rb'.
#
# source://bigdecimal-3.3.1/lib/bigdecimal.rb:237
module BigMath
  class << self
    # call-seq:
    #   BigMath.exp(decimal, numeric)    -> BigDecimal
    #
    # Computes the value of e (the base of natural logarithms) raised to the
    # power of +decimal+, to the specified number of digits of precision.
    #
    # If +decimal+ is infinity, returns Infinity.
    #
    # If +decimal+ is NaN, returns NaN.
    #
    # source://bigdecimal-3.3.1/lib/bigdecimal.rb:328
    def exp(x, prec); end

    # call-seq:
    #   BigMath.log(decimal, numeric)    -> BigDecimal
    #
    # Computes the natural logarithm of +decimal+ to the specified number of
    # digits of precision, +numeric+.
    #
    # If +decimal+ is zero or negative, raises Math::DomainError.
    #
    # If +decimal+ is positive infinity, returns Infinity.
    #
    # If +decimal+ is NaN, returns NaN.
    #
    # @raise [Math::DomainError]
    #
    # source://bigdecimal-3.3.1/lib/bigdecimal.rb:251
    def log(x, prec); end

    private

    # source://bigdecimal-3.3.1/lib/bigdecimal.rb:306
    def _exp_taylor(x, prec); end
  end
end

# source://bigdecimal-3.3.1/lib/bigdecimal/util.rb:163
class Complex < ::Numeric
  # call-seq:
  #     cmp.to_d             -> bigdecimal
  #     cmp.to_d(precision)  -> bigdecimal
  #
  # Returns the value as a BigDecimal.
  # If the imaginary part is not +0+, an error is raised
  #
  # The +precision+ parameter is used to determine the number of
  # significant digits for the result. When +precision+ is set to +0+,
  # the number of digits to represent the float being converted is determined
  # automatically.
  # The default +precision+ is +0+.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     Complex(0.1234567, 0).to_d(4)   # => 0.1235e0
  #     Complex(Rational(22, 7), 0).to_d(3)   # => 0.314e1
  #     Complex(1, 1).to_d   # raises ArgumentError
  #
  # See also Kernel.BigDecimal.
  #
  # source://bigdecimal-3.3.1/lib/bigdecimal/util.rb:164
  def to_d(precision = T.unsafe(nil)); end
end

# source://bigdecimal-3.3.1/lib/bigdecimal/util.rb:172
class NilClass
  # call-seq:
  #     nil.to_d -> bigdecimal
  #
  # Returns nil represented as a BigDecimal.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     nil.to_d   # => 0.0
  #
  # source://bigdecimal-3.3.1/lib/bigdecimal/util.rb:183
  def to_d; end
end

# source://bigdecimal-3.3.1/lib/bigdecimal/util.rb:134
class Rational < ::Numeric
  # call-seq:
  #     rat.to_d(precision)  -> bigdecimal
  #
  # Returns the value as a BigDecimal.
  #
  # The +precision+ parameter is used to determine the number of
  # significant digits for the result. When +precision+ is set to +0+,
  # the number of digits to represent the float being converted is determined
  # automatically.
  # The default +precision+ is +0+.
  #
  #     require 'bigdecimal'
  #     require 'bigdecimal/util'
  #
  #     Rational(22, 7).to_d(3)   # => 0.314e1
  #
  # See also Kernel.BigDecimal.
  #
  # source://bigdecimal-3.3.1/lib/bigdecimal/util.rb:135
  def to_d(precision = T.unsafe(nil)); end
end
