# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cancancan` gem.
# Please instead update this file by running `bin/tapioca gem cancancan`.

# this class is responsible of normalizing the hash of conditions
# by exploding has_many through associations
# when a condition is defined with an has_many through association this is exploded in all its parts
# TODO: it could identify STI and normalize it
#
# source://cancancan-3.4.0/lib/cancan/version.rb:3
module CanCan
  class << self
    # Determines how CanCan should build queries when calling accessible_by,
    # if the query will contain a join. The default strategy is `:subquery`.
    #
    #   # config/initializers/cancan.rb
    #   CanCan.accessible_by_strategy = :subquery
    #
    # Valid strategies are:
    # - :subquery - Creates a nested query with all joins, wrapped by a
    #               WHERE IN query.
    # - :left_join - Calls the joins directly using `left_joins`, and
    #                ensures records are unique using `distinct`. Note that
    #                `distinct` is not reliable in some cases. See
    #                https://github.com/CanCanCommunity/cancancan/pull/605
    #
    # source://cancancan-3.4.0/lib/cancan/config.rb:27
    def accessible_by_strategy; end

    # source://cancancan-3.4.0/lib/cancan/config.rb:44
    def accessible_by_strategy=(value); end

    # source://cancancan-3.4.0/lib/cancan/config.rb:33
    def default_accessible_by_strategy; end

    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/config.rb:74
    def does_not_support_subquery_strategy?; end

    # source://cancancan-3.4.0/lib/cancan/config.rb:4
    def valid_accessible_by_strategies; end

    # @raise [ArgumentError]
    #
    # source://cancancan-3.4.0/lib/cancan/config.rb:68
    def validate_accessible_by_strategy!(value); end

    # source://cancancan-3.4.0/lib/cancan/config.rb:54
    def with_accessible_by_strategy(value); end
  end
end

# This module is designed to be included into an Ability class. This will
# provide the "can" methods for defining and checking abilities.
#
#   class Ability
#     include CanCan::Ability
#
#     def initialize(user)
#       if user.admin?
#         can :manage, :all
#       else
#         can :read, :all
#       end
#     end
#   end
#
# source://cancancan-3.4.0/lib/cancan/ability/rules.rb:4
module CanCan::Ability
  include ::CanCan::Ability::Rules
  include ::CanCan::Ability::Actions
  include ::CanCan::UnauthorizedMessageResolver
  include ::CanCan::Ability::StrongParameterSupport

  # source://cancancan-3.4.0/lib/cancan/ability.rb:185
  def attributes_for(action, subject); end

  # See ControllerAdditions#authorize! for documentation.
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:176
  def authorize!(action, subject, *args); end

  # Defines which abilities are allowed using two arguments. The first one is the action
  # you're setting the permission for, the second one is the class of object you're setting it on.
  #
  #   can :update, Article
  #
  # You can pass an array for either of these parameters to match any one.
  # Here the user has the ability to update or destroy both articles and comments.
  #
  #   can [:update, :destroy], [Article, Comment]
  #
  # You can pass :all to match any object and :manage to match any action. Here are some examples.
  #
  #   can :manage, :all
  #   can :update, :all
  #   can :manage, Project
  #
  # You can pass a hash of conditions as the third argument. Here the user can only see active projects which he owns.
  #
  #   can :read, Project, :active => true, :user_id => user.id
  #
  # See ActiveRecordAdditions#accessible_by for how to use this in database queries. These conditions
  # are also used for initial attributes when building a record in ControllerAdditions#load_resource.
  #
  # If the conditions hash does not give you enough control over defining abilities, you can use a block
  # along with any Ruby code you want.
  #
  #   can :update, Project do |project|
  #     project.groups.include?(user.group)
  #   end
  #
  # If the block returns true then the user has that :update ability for that project, otherwise he
  # will be denied access. The downside to using a block is that it cannot be used to generate
  # conditions for database queries.
  #
  # You can pass custom objects into this "can" method, this is usually done with a symbol
  # and is useful if a class isn't available to define permissions on.
  #
  #   can :read, :stats
  #   can? :read, :stats # => true
  #
  # IMPORTANT: Neither a hash of conditions nor a block will be used when checking permission on a class.
  #
  #   can :update, Project, :priority => 3
  #   can? :update, Project # => true
  #
  # If you pass no arguments to +can+, the action, class, and object will be passed to the block and the
  # block will always be executed. This allows you to override the full behavior if the permissions are
  # defined in an external source such as the database.
  #
  #   can do |action, object_class, object|
  #     # check the database and return true/false
  #   end
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:144
  def can(action = T.unsafe(nil), subject = T.unsafe(nil), *attributes_and_conditions, &block); end

  # Check if the user has permission to perform a given action on an object.
  #
  #   can? :destroy, @project
  #
  # You can also pass the class instead of an instance (if you don't have one handy).
  #
  #   can? :create, Project
  #
  # Nested resources can be passed through a hash, this way conditions which are
  # dependent upon the association will work when using a class.
  #
  #   can? :create, @category => Project
  #
  # You can also pass multiple objects to check. You only need to pass a hash
  # following the pattern { :any => [many subjects] }. The behaviour is check if
  # there is a permission on any of the given objects.
  #
  #   can? :create, {:any => [Project, Rule]}
  #
  #
  # Any additional arguments will be passed into the "can" block definition. This
  # can be used to pass more information about the user's request for example.
  #
  #   can? :create, Project, request.remote_ip
  #
  #   can :create, Project do |project, remote_ip|
  #     # ...
  #   end
  #
  # Not only can you use the can? method in the controller and view (see ControllerAdditions),
  # but you can also call it directly on an ability instance.
  #
  #   ability.can? :destroy, @project
  #
  # This makes testing a user's abilities very easy.
  #
  #   def test "user can only destroy projects which he owns"
  #     user = User.new
  #     ability = Ability.new(user)
  #     assert ability.can?(:destroy, Project.new(:user => user))
  #     assert ability.cannot?(:destroy, Project.new)
  #   end
  #
  # Also see the RSpec Matchers to aid in testing.
  #
  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:74
  def can?(action, subject, attribute = T.unsafe(nil), *extra_args); end

  # Defines an ability which cannot be done. Accepts the same arguments as "can".
  #
  #   can :read, :all
  #   cannot :read, Comment
  #
  # A block can be passed just like "can", however if the logic is complex it is recommended
  # to use the "can" method.
  #
  #   cannot :read, Product do |product|
  #     product.invisible?
  #   end
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:160
  def cannot(action = T.unsafe(nil), subject = T.unsafe(nil), *attributes_and_conditions, &block); end

  # Convenience method which works the same as "can?" but returns the opposite value.
  #
  #   cannot? :destroy, @project
  #
  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:87
  def cannot?(*args); end

  # source://cancancan-3.4.0/lib/cancan/ability.rb:275
  def extract_rule_in_permissions(permissions_list, rule); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:193
  def has_block?(action, subject); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:197
  def has_raw_sql?(action, subject); end

  # Copies all rules and aliased actions of the given +CanCan::Ability+ and adds them to +self+.
  #   class ReadAbility
  #     include CanCan::Ability
  #
  #     def initialize
  #       can :read, User
  #       alias_action :show, :index, to: :see
  #     end
  #   end
  #
  #   class WritingAbility
  #     include CanCan::Ability
  #
  #     def initialize
  #       can :edit, User
  #       alias_action :create, :update, to: :modify
  #     end
  #   end
  #
  #   read_ability = ReadAbility.new
  #   read_ability.can? :edit, User.new #=> false
  #   read_ability.merge(WritingAbility.new)
  #   read_ability.can? :edit, User.new #=> true
  #   read_ability.aliased_actions #=> [:see => [:show, :index], :modify => [:create, :update]]
  #
  # If there are collisions when merging the +aliased_actions+, the actions on +self+ will be
  # overwritten.
  #
  # class ReadAbility
  #   include CanCan::Ability
  #
  #   def initialize
  #     alias_action :show, :index, to: :see
  #   end
  # end
  #
  # class ShowAbility
  #   include CanCan::Ability
  #
  #   def initialize
  #     alias_action :show, to: :see
  #   end
  # end
  #
  # read_ability = ReadAbility.new
  # read_ability.merge(ShowAbility)
  # read_ability.aliased_actions #=> [:see => [:show]]
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:248
  def merge(ability); end

  # source://cancancan-3.4.0/lib/cancan/ability.rb:170
  def model_adapter(model_class, action); end

  # Return a hash of permissions for the user in the format of:
  #   {
  #     can: can_hash,
  #     cannot: cannot_hash
  #   }
  #
  # Where can_hash and cannot_hash are formatted thusly:
  #   {
  #     action: { subject: [attributes] }
  #   }
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:266
  def permissions; end

  # User shouldn't specify targets with names of real actions or it will cause Seg fault
  #
  # @raise [Error]
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:165
  def validate_target(target); end

  private

  # source://cancancan-3.4.0/lib/cancan/ability.rb:303
  def alternative_subjects(subject); end

  # It translates to an array the subject or the hash with multiple subjects given to can?.
  #
  # source://cancancan-3.4.0/lib/cancan/ability.rb:295
  def extract_subjects(subject); end

  # source://cancancan-3.4.0/lib/cancan/ability.rb:286
  def unauthorized_message_keys(action, subject); end
end

# source://cancancan-3.4.0/lib/cancan/ability/actions.rb:5
module CanCan::Ability::Actions
  # Alias one or more actions into another one.
  #
  #   alias_action :update, :destroy, :to => :modify
  #   can :modify, Comment
  #
  # Then :modify permission will apply to both :update and :destroy requests.
  #
  #   can? :update, Comment # => true
  #   can? :destroy, Comment # => true
  #
  # This only works in one direction. Passing the aliased action into the "can?" call
  # will not work because aliases are meant to generate more generic actions.
  #
  #   alias_action :update, :destroy, :to => :modify
  #   can :update, Comment
  #   can? :modify, Comment # => false
  #
  # Unless that exact alias is used.
  #
  #   can :modify, Comment
  #   can? :modify, Comment # => true
  #
  # The following aliases are added by default for conveniently mapping common controller actions.
  #
  #   alias_action :index, :show, :to => :read
  #   alias_action :new, :to => :create
  #   alias_action :edit, :to => :update
  #
  # This way one can use params[:action] in the controller to determine the permission.
  #
  # source://cancancan-3.4.0/lib/cancan/ability/actions.rb:35
  def alias_action(*args); end

  # Returns a hash of aliased actions. The key is the target and the value is an array of actions aliasing the key.
  #
  # source://cancancan-3.4.0/lib/cancan/ability/actions.rb:43
  def aliased_actions; end

  # Removes previously aliased actions including the defaults.
  #
  # source://cancancan-3.4.0/lib/cancan/ability/actions.rb:48
  def clear_aliased_actions; end

  private

  # Given an action, it will try to find all of the actions which are aliased to it.
  # This does the opposite kind of lookup as expand_actions.
  #
  # source://cancancan-3.4.0/lib/cancan/ability/actions.rb:64
  def aliases_for_action(action); end

  # source://cancancan-3.4.0/lib/cancan/ability/actions.rb:54
  def default_alias_actions; end

  # Accepts an array of actions and returns an array of actions which match.
  # This should be called before "matches?" and other checking methods since they
  # rely on the actions to be expanded.
  #
  # source://cancancan-3.4.0/lib/cancan/ability/actions.rb:79
  def expand_actions(actions); end

  # source://cancancan-3.4.0/lib/cancan/ability/actions.rb:72
  def expanded_actions; end
end

# source://cancancan-3.4.0/lib/cancan/ability/rules.rb:5
module CanCan::Ability::Rules
  protected

  # Must be protected as an ability can merge with other abilities.
  # This means that an ability must expose their rules with another ability.
  #
  # source://cancancan-3.4.0/lib/cancan/ability/rules.rb:10
  def rules; end

  private

  # source://cancancan-3.4.0/lib/cancan/ability/rules.rb:16
  def add_rule(rule); end

  # source://cancancan-3.4.0/lib/cancan/ability/rules.rb:21
  def add_rule_to_index(rule, position); end

  # Optimizes the order of the rules, so that rules with the :all subject are evaluated first.
  #
  # source://cancancan-3.4.0/lib/cancan/ability/rules.rb:82
  def optimize_order!(rules); end

  # source://cancancan-3.4.0/lib/cancan/ability/rules.rb:47
  def possible_relevant_rules(subject); end

  # Returns an array of Rule instances which match the action and subject
  # This does not take into consideration any hash conditions or block statements
  #
  # source://cancancan-3.4.0/lib/cancan/ability/rules.rb:35
  def relevant_rules(action, subject); end

  # source://cancancan-3.4.0/lib/cancan/ability/rules.rb:59
  def relevant_rules_for_match(action, subject); end

  # source://cancancan-3.4.0/lib/cancan/ability/rules.rb:69
  def relevant_rules_for_query(action, subject); end
end

# source://cancancan-3.4.0/lib/cancan/ability/strong_parameter_support.rb:5
module CanCan::Ability::StrongParameterSupport
  # Returns an array of attributes suitable for use with strong parameters
  #
  # Note: reversing the relevant rules is important. Normal order means that 'cannot'
  # rules will come before 'can' rules. However, you can't remove attributes before
  # they are added. The 'reverse' is so that attributes will be added before the
  # 'cannot' rules remove them.
  #
  # source://cancancan-3.4.0/lib/cancan/ability/strong_parameter_support.rb:12
  def permitted_attributes(action, subject); end

  private

  # source://cancancan-3.4.0/lib/cancan/ability/strong_parameter_support.rb:30
  def get_attributes(rule, subject); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/ability/strong_parameter_support.rb:25
  def subject_class?(subject); end
end

# This error is raised when a user isn't allowed to access a given controller action.
# This usually happens within a call to ControllerAdditions#authorize! but can be
# raised manually.
#
#   raise CanCan::AccessDenied.new("Not authorized!", :read, Article)
#
# The passed message, action, and subject are optional and can later be retrieved when
# rescuing from the exception.
#
#   exception.message # => "Not authorized!"
#   exception.action # => :read
#   exception.subject # => Article
#
# If the message is not specified (or is nil) it will default to "You are not authorized
# to access this page." This default can be overridden by setting default_message.
#
#   exception.default_message = "Default error message"
#   exception.message # => "Default error message"
#
# See ControllerAdditions#authorize! for more information on rescuing from this exception
# and customizing the message using I18n.
#
# source://cancancan-3.4.0/lib/cancan/exceptions.rb:46
class CanCan::AccessDenied < ::CanCan::Error
  # @return [AccessDenied] a new instance of AccessDenied
  #
  # source://cancancan-3.4.0/lib/cancan/exceptions.rb:50
  def initialize(message = T.unsafe(nil), action = T.unsafe(nil), subject = T.unsafe(nil), conditions = T.unsafe(nil)); end

  # Returns the value of attribute action.
  #
  # source://cancancan-3.4.0/lib/cancan/exceptions.rb:47
  def action; end

  # Returns the value of attribute conditions.
  #
  # source://cancancan-3.4.0/lib/cancan/exceptions.rb:47
  def conditions; end

  # Sets the attribute default_message
  #
  # @param value the value to set the attribute default_message to.
  #
  # source://cancancan-3.4.0/lib/cancan/exceptions.rb:48
  def default_message=(_arg0); end

  # source://cancancan-3.4.0/lib/cancan/exceptions.rb:62
  def inspect; end

  # Returns the value of attribute subject.
  #
  # source://cancancan-3.4.0/lib/cancan/exceptions.rb:47
  def subject; end

  # source://cancancan-3.4.0/lib/cancan/exceptions.rb:58
  def to_s; end
end

# Raised when an unexpected argument is passed as an attribute
#
# source://cancancan-3.4.0/lib/cancan/exceptions.rb:20
class CanCan::AttributeArgumentError < ::CanCan::Error; end

# Raised when using check_authorization without calling authorize!
#
# source://cancancan-3.4.0/lib/cancan/exceptions.rb:14
class CanCan::AuthorizationNotPerformed < ::CanCan::Error; end

# Raised when a rule is created with both a block and a hash of conditions
#
# source://cancancan-3.4.0/lib/cancan/exceptions.rb:17
class CanCan::BlockAndConditionsError < ::CanCan::Error; end

# source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:4
module CanCan::ConditionsMatcher
  # Matches the block or conditions hash
  #
  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:6
  def matches_conditions?(action, subject, attribute = T.unsafe(nil), *extra_args); end

  private

  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:106
  def call_block_with_all(action, subject, *extra_args); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:85
  def condition_match?(attribute, value); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:118
  def conditions_empty?; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:98
  def hash_condition_match?(attribute, value); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:64
  def matches_all_conditions?(adapter, subject, conditions); end

  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:21
  def matches_block_conditions(subject, *extra_args); end

  # Checks if the given subject matches the given conditions hash.
  # This behavior can be overridden by a model adapter by defining two class methods:
  # override_matching_for_conditions?(subject, conditions) and
  # matches_conditions_hash?(subject, conditions)
  #
  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:52
  def matches_conditions_hash?(subject, conditions = T.unsafe(nil)); end

  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:75
  def matches_hash_conditions(adapter, subject, conditions); end

  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:27
  def matches_non_block_conditions(subject); end

  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:114
  def model_adapter(subject); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:35
  def nested_subject_matches_conditions?(subject_hash); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/conditions_matcher.rb:16
  def subject_class?(subject); end
end

# This module is automatically included into all controllers.
# It also makes the "can?" and "cannot?" methods available to all views.
#
# source://cancancan-3.4.0/lib/cancan/controller_additions.rb:6
module CanCan::ControllerAdditions
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CanCan::ControllerAdditions::ClassMethods

  # Raises a CanCan::AccessDenied exception if the current_ability cannot
  # perform the given action. This is usually called in a controller action or
  # before filter to perform the authorization.
  #
  #   def show
  #     @article = Article.find(params[:id])
  #     authorize! :read, @article
  #   end
  #
  # A :message option can be passed to specify a different message.
  #
  #   authorize! :read, @article, :message => "Not authorized to read #{@article.name}"
  #
  # You can also use I18n to customize the message. Action aliases defined in Ability work here.
  #
  #   en:
  #     unauthorized:
  #       manage:
  #         all: "Not authorized to %{action} %{subject}."
  #         user: "Not allowed to manage other user accounts."
  #       update:
  #         project: "Not allowed to update this project."
  #
  # You can rescue from the exception in the controller to customize how unauthorized
  # access is displayed to the user.
  #
  #   class ApplicationController < ActionController::Base
  #     rescue_from CanCan::AccessDenied do |exception|
  #       redirect_to root_url, :alert => exception.message
  #     end
  #   end
  #
  # See the CanCan::AccessDenied exception for more details on working with the exception.
  #
  # See the load_and_authorize_resource method to automatically add the authorize! behavior
  # to the default RESTful actions.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:337
  def authorize!(*args); end

  # Use in the controller or view to check the user's permission for a given action
  # and object.
  #
  #   can? :destroy, @project
  #
  # You can also pass the class instead of an instance (if you don't have one handy).
  #
  #   <% if can? :create, Project %>
  #     <%= link_to "New Project", new_project_path %>
  #   <% end %>
  #
  # If it's a nested resource, you can pass the parent instance in a hash. This way it will
  # check conditions which reach through that association.
  #
  #   <% if can? :create, @category => Project %>
  #     <%= link_to "New Project", new_project_path %>
  #   <% end %>
  #
  # This simply calls "can?" on the current_ability. See Ability#can?.
  #
  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:376
  def can?(*args); end

  # Convenience method which works the same as "can?" but returns the opposite value.
  #
  #   cannot? :destroy, @project
  #
  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:384
  def cannot?(*args); end

  # Creates and returns the current user's ability and caches it. If you
  # want to override how the Ability is defined then this is the place.
  # Just define the method in the controller to change behavior.
  #
  #   def current_ability
  #     # instead of Ability.new(current_user)
  #     @current_ability ||= UserAbility.new(current_account)
  #   end
  #
  # Notice it is important to cache the ability object so it is not
  # recreated every time.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:353
  def current_ability; end

  class << self
    # @private
    #
    # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:295
    def included(base); end
  end

  module GeneratedClassMethods
    def _cancan_skipper; end
    def _cancan_skipper=(value); end
    def _cancan_skipper?; end
  end

  module GeneratedInstanceMethods
    def _cancan_skipper; end
    def _cancan_skipper=(value); end
    def _cancan_skipper?; end
  end
end

# source://cancancan-3.4.0/lib/cancan/controller_additions.rb:7
module CanCan::ControllerAdditions::ClassMethods
  # Sets up a before filter which authorizes the resource using the instance variable.
  # For example, if you have an ArticlesController it will check the @article instance variable
  # and ensure the user can perform the current action on it. Under the hood it is doing
  # something like the following.
  #
  #   authorize!(params[:action].to_sym, @article || Article)
  #
  # Call this method directly on the controller class.
  #
  #   class BooksController < ApplicationController
  #     authorize_resource
  #   end
  #
  # If you pass in the name of a resource which does not match the controller it will assume
  # it is a parent resource.
  #
  #   class BooksController < ApplicationController
  #     authorize_resource :author
  #     authorize_resource :book
  #   end
  #
  # Here it will authorize :+show+, @+author+ on every action before authorizing the book.
  #
  # That first argument is optional and will default to the singular name of the controller.
  # A hash of options (see below) can also be passed to this method to further customize it.
  #
  # See load_and_authorize_resource to automatically load the resource too.
  #
  # Options:
  # [:+only+]
  #   Only applies before filter to given actions.
  #
  # [:+except+]
  #   Does not apply before filter to given actions.
  #
  # [:+singleton+]
  #   Pass +true+ if this is a singleton resource through a +has_one+ association.
  #
  # [:+parent+]
  #   True or false depending on if the resource is considered a parent resource.
  #   This defaults to +true+ if a resource name is given which does not match the controller.
  #
  # [:+class+]
  #   The class to use for the model (string or constant). This passed in when the instance variable is not set.
  #   Pass +false+ if there is no associated class for this resource and it will use a symbol of the resource name.
  #
  # [:+instance_name+]
  #   The name of the instance variable for this resource.
  #
  # [:+through+]
  #   Authorize conditions on this parent resource when instance isn't available.
  #
  # [:+prepend+]
  #   Passing +true+ will use prepend_before_action instead of a normal before_action.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:180
  def authorize_resource(*args); end

  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:286
  def cancan_resource_class; end

  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:290
  def cancan_skipper; end

  # Add this to a controller to ensure it performs authorization through +authorize+! or +authorize_resource+ call.
  # If neither of these authorization methods are called,
  # a CanCan::AuthorizationNotPerformed exception will be raised.
  # This is normally added to the ApplicationController to ensure all controller actions do authorization.
  #
  #   class ApplicationController < ActionController::Base
  #     check_authorization
  #   end
  #
  # See skip_authorization_check to bypass this check on specific controller actions.
  #
  # Options:
  # [:+only+]
  #   Only applies to given actions.
  #
  # [:+except+]
  #   Does not apply to given actions.
  #
  # [:+if+]
  #   Supply the name of a controller method to be called.
  #   The authorization check only takes place if this returns true.
  #
  #     check_authorization :if => :admin_controller?
  #
  # [:+unless+]
  #   Supply the name of a controller method to be called.
  #   The authorization check only takes place if this returns false.
  #
  #     check_authorization :unless => :devise_controller?
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:260
  def check_authorization(options = T.unsafe(nil)); end

  # Sets up a before filter which loads and authorizes the current resource. This performs both
  # load_resource and authorize_resource and accepts the same arguments. See those methods for details.
  #
  #   class BooksController < ApplicationController
  #     load_and_authorize_resource
  #   end
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:15
  def load_and_authorize_resource(*args); end

  # Sets up a before filter which loads the model resource into an instance variable.
  # For example, given an ArticlesController it will load the current article into the @article
  # instance variable. It does this by either calling Article.find(params[:id]) or
  # Article.new(params[:article]) depending upon the action. The index action will
  # automatically set @articles to Article.accessible_by(current_ability).
  #
  # If a conditions hash is used in the Ability, the +new+ and +create+ actions will set
  # the initial attributes based on these conditions. This way these actions will satisfy
  # the ability restrictions.
  #
  # Call this method directly on the controller class.
  #
  #   class BooksController < ApplicationController
  #     load_resource
  #   end
  #
  # A resource is not loaded if the instance variable is already set. This makes it easy to override
  # the behavior through a before_action on certain actions.
  #
  #   class BooksController < ApplicationController
  #     before_action :find_book_by_permalink, :only => :show
  #     load_resource
  #
  #     private
  #
  #     def find_book_by_permalink
  #       @book = Book.find_by_permalink!(params[:id])
  #     end
  #   end
  #
  # If a name is provided which does not match the controller it assumes it is a parent resource. Child
  # resources can then be loaded through it.
  #
  #   class BooksController < ApplicationController
  #     load_resource :author
  #     load_resource :book, :through => :author
  #   end
  #
  # Here the author resource will be loaded before each action using params[:author_id]. The book resource
  # will then be loaded through the @author instance variable.
  #
  # That first argument is optional and will default to the singular name of the controller.
  # A hash of options (see below) can also be passed to this method to further customize it.
  #
  # See load_and_authorize_resource to automatically authorize the resource too.
  #
  # Options:
  # [:+only+]
  #   Only applies before filter to given actions.
  #
  # [:+except+]
  #   Does not apply before filter to given actions.
  #
  # [:+through+]
  #   Load this resource through another one. This should match the name of the parent instance variable or method.
  #
  # [:+through_association+]
  #   The name of the association to fetch the child records through the parent resource.
  #   This is normally not needed because it defaults to the pluralized resource name.
  #
  # [:+shallow+]
  #   Pass +true+ to allow this resource to be loaded directly when parent is +nil+. Defaults to +false+.
  #
  # [:+singleton+]
  #   Pass +true+ if this is a singleton resource through a +has_one+ association.
  #
  # [:+parent+]
  #   True or false depending on if the resource is considered a parent resource.
  #   This defaults to +true+ if a resource name is given which does not match the controller.
  #
  # [:+class+]
  #   The class to use for the model (string or constant).
  #
  # [:+instance_name+]
  #   The name of the instance variable to load the resource into.
  #
  # [:+find_by+]
  #   Find using a different attribute other than id. For example.
  #
  #     load_resource :find_by => :permalink # will use find_by_permalink!(params[:id])
  #
  # [:+id_param+]
  #   Find using a param key other than :id. For example:
  #
  #     load_resource :id_param => :url # will use find(params[:url])
  #
  # [:+collection+]
  #   Specify which actions are resource collection actions in addition to :+index+. This
  #   is usually not necessary because it will try to guess depending on if the id param is present.
  #
  #     load_resource :collection => [:sort, :list]
  #
  # [:+new+]
  #   Specify which actions are new resource actions in addition to :+new+ and :+create+.
  #   Pass an action name into here if you would like to build a new resource instead of
  #   fetch one.
  #
  #     load_resource :new => :build
  #
  # [:+prepend+]
  #   Passing +true+ will use prepend_before_action instead of a normal before_action.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:121
  def load_resource(*args); end

  # Call this in the class of a controller to skip the check_authorization behavior on the actions.
  #
  #   class HomeController < ApplicationController
  #     skip_authorization_check :only => :index
  #   end
  #
  # Any arguments are passed to the +before_action+ it triggers.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:281
  def skip_authorization_check(*args); end

  # Skip the authorization behavior of CanCan. This is useful when using +load_and_authorize_resource+ but want to
  # only do loading on certain actions. You can pass :only and :except options to specify which actions to
  # skip the effects on. It will apply to all actions by default.
  #
  #   class ProjectsController < ApplicationController
  #     load_and_authorize_resource
  #     skip_authorize_resource :only => :index
  #   end
  #
  # You can also pass the resource name as the first argument to skip that resource.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:224
  def skip_authorize_resource(*args); end

  # Skip both the loading and authorization behavior of CanCan for this given controller. This is primarily
  # useful to skip the behavior of a superclass. You can pass :only and :except options to specify which actions
  # to skip the effects on. It will apply to all actions by default.
  #
  #   class ProjectsController < SomeOtherController
  #     skip_load_and_authorize_resource :only => :index
  #   end
  #
  # You can also pass the resource name as the first argument to skip that resource.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:193
  def skip_load_and_authorize_resource(*args); end

  # Skip the loading behavior of CanCan. This is useful when using +load_and_authorize_resource+ but want to
  # only do authorization on certain actions. You can pass :only and :except options to specify which actions to
  # skip the effects on. It will apply to all actions by default.
  #
  #   class ProjectsController < ApplicationController
  #     load_and_authorize_resource
  #     skip_load_resource :only => :index
  #   end
  #
  # You can also pass the resource name as the first argument to skip that resource.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_additions.rb:208
  def skip_load_resource(*args); end
end

# Handle the load and authorization controller logic
# so we don't clutter up all controllers with non-interface methods.
# This class is used internally, so you do not need to call methods directly on it.
#
# source://cancancan-3.4.0/lib/cancan/controller_resource.rb:8
class CanCan::ControllerResource
  include ::CanCan::ControllerResourceNameFinder
  include ::CanCan::ControllerResourceFinder
  include ::CanCan::ControllerResourceBuilder
  include ::CanCan::ControllerResourceSanitizer
  include ::CanCan::ControllerResourceLoader

  # @return [ControllerResource] a new instance of ControllerResource
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:25
  def initialize(controller, *args); end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:37
  def authorize_resource; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:32
  def load_and_authorize_resource; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:43
  def parent?; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:47
  def skip?(behavior); end

  protected

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:119
  def collection_actions; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:105
  def collection_instance; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:101
  def collection_instance=(instance); end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:115
  def instance_name; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:77
  def load_collection?; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:73
  def load_instance?; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:81
  def member_action?; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:111
  def parameters_require_sanitizing?; end

  # Returns the class used for this resource. This can be overridden by the :class option.
  # If +false+ is passed in it will use the resource name as a symbol in which case it should
  # only be used for authorization, not loading since there's no class to load through.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:60
  def resource_class; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:87
  def resource_class_with_parent; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:95
  def resource_instance; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:91
  def resource_instance=(instance); end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:123
  def save_actions; end

  private

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:129
  def action_exists_in?(options); end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:133
  def adapter; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:137
  def current_ability; end

  class << self
    # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:11
    def add_before_action(controller_class, method, *args); end

    # source://cancancan-3.4.0/lib/cancan/controller_resource.rb:21
    def before_callback_name(options); end
  end
end

# source://cancancan-3.4.0/lib/cancan/controller_resource_builder.rb:4
module CanCan::ControllerResourceBuilder
  protected

  # source://cancancan-3.4.0/lib/cancan/controller_resource_builder.rb:12
  def assign_attributes(resource); end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_builder.rb:7
  def build_resource; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_builder.rb:20
  def initial_attributes; end
end

# source://cancancan-3.4.0/lib/cancan/controller_resource_finder.rb:4
module CanCan::ControllerResourceFinder
  protected

  # source://cancancan-3.4.0/lib/cancan/controller_resource_finder.rb:21
  def find_by_dynamic_finder; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_finder.rb:26
  def find_by_find_by_finder; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_finder.rb:7
  def find_resource; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_finder.rb:17
  def find_resource_using_find_by; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_finder.rb:30
  def id_param; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_finder.rb:34
  def id_param_key; end
end

# source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:8
module CanCan::ControllerResourceLoader
  include ::CanCan::ControllerResourceNameFinder
  include ::CanCan::ControllerResourceFinder
  include ::CanCan::ControllerResourceBuilder
  include ::CanCan::ControllerResourceSanitizer

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:14
  def load_resource; end

  protected

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:98
  def authorization_action; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:50
  def fetch_parent(name); end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:102
  def load_collection; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:106
  def load_resource_instance; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:26
  def new_actions; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:94
  def parent_authorization_action; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:63
  def parent_name; end

  # The object to load this resource through.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:59
  def parent_resource; end

  # The object that methods (such as "find", "new" or "build") are called on.
  # If the :through option is passed it will go through an association on that instance.
  # If the :shallow option is passed it will use the resource_class if there's no parent
  # If the :singleton option is passed it won't use the association because it needs to be handled later.
  #
  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:90
  def resource_base; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:75
  def resource_base_through; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:67
  def resource_base_through_parent_resource; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:42
  def resource_params; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:30
  def resource_params_by_key(key); end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:36
  def resource_params_by_namespaced_name; end

  private

  # source://cancancan-3.4.0/lib/cancan/controller_resource_loader.rb:116
  def extract_key(value); end
end

# source://cancancan-3.4.0/lib/cancan/controller_resource_name_finder.rb:4
module CanCan::ControllerResourceNameFinder
  protected

  # source://cancancan-3.4.0/lib/cancan/controller_resource_name_finder.rb:15
  def name; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_name_finder.rb:7
  def name_from_controller; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_name_finder.rb:19
  def namespace; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_name_finder.rb:11
  def namespaced_name; end
end

# source://cancancan-3.4.0/lib/cancan/controller_resource_sanitizer.rb:4
module CanCan::ControllerResourceSanitizer
  protected

  # source://cancancan-3.4.0/lib/cancan/controller_resource_sanitizer.rb:24
  def params_method; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_sanitizer.rb:18
  def params_methods; end

  # source://cancancan-3.4.0/lib/cancan/controller_resource_sanitizer.rb:7
  def sanitize_parameters; end
end

# A general CanCan exception
#
# source://cancancan-3.4.0/lib/cancan/exceptions.rb:5
class CanCan::Error < ::StandardError; end

# Raised when removed code is called, an alternative solution is provided in message.
#
# source://cancancan-3.4.0/lib/cancan/exceptions.rb:11
class CanCan::ImplementationRemoved < ::CanCan::Error; end

# source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:4
module CanCan::ModelAdapters; end

# source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:5
class CanCan::ModelAdapters::AbstractAdapter
  # @return [AbstractAdapter] a new instance of AbstractAdapter
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:61
  def initialize(model_class, rules); end

  # @raise [NotImplemented]
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:66
  def database_records; end

  # Returns the value of attribute model_class.
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:6
  def model_class; end

  class << self
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:13
    def adapter_class(model_class); end

    # Override if you need custom find behavior
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:23
    def find(model_class, id); end

    # Used to determine if the given adapter should be used for the passed in class.
    #
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:18
    def for_class?(_member_class); end

    # @private
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:8
    def inherited(subclass); end

    # Override if override_condition_matching? returns true
    #
    # @raise [NotImplemented]
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:57
    def matches_condition?(_subject, _name, _value); end

    # Override if override_conditions_hash_matching? returns true
    #
    # @raise [NotImplemented]
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:34
    def matches_conditions_hash?(_subject, _conditions); end

    # Override if override_nested_subject_conditions_matching? returns true
    #
    # @raise [NotImplemented]
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:46
    def nested_subject_matches_conditions?(_parent, _child, _all_conditions); end

    # Used to determine if this model adapter will override the matching behavior for a specific condition.
    # If this returns true then matches_condition? will be called. See Rule#matches_conditions_hash
    #
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:52
    def override_condition_matching?(_subject, _name, _value); end

    # Used to determine if this model adapter will override the matching behavior for a hash of conditions.
    # If this returns true then matches_conditions_hash? will be called. See Rule#matches_conditions_hash
    #
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:29
    def override_conditions_hash_matching?(_subject, _conditions); end

    # Used above override_conditions_hash_matching to determine if this model adapter will override the
    # matching behavior for nested subject.
    # If this returns true then nested_subject_matches_conditions? will be called.
    #
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/abstract_adapter.rb:41
    def override_nested_subject_conditions_matching?(_parent, _child, _all_conditions); end
  end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_4_adapter.rb:5
class CanCan::ModelAdapters::ActiveRecord4Adapter < ::CanCan::ModelAdapters::ActiveRecordAdapter
  private

  # As of rails 4, `includes()` no longer causes active record to
  # look inside the where clause to decide to outer join tables
  # you're using in the where. Instead, `references()` is required
  # in addition to `includes()` to force the outer join.
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_4_adapter.rb:37
  def build_joins_relation(relation, *_where_conditions); end

  # Rails 4.2 deprecates `sanitize_sql_hash_for_conditions`
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_4_adapter.rb:42
  def sanitize_sql(conditions); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_4_adapter.rb:50
  def sanitize_sql_activerecord4(conditions); end

  class << self
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_4_adapter.rb:9
    def for_class?(model_class); end

    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_4_adapter.rb:17
    def matches_condition?(subject, name, value); end

    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_4_adapter.rb:13
    def override_condition_matching?(subject, name, _value); end
  end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_5_adapter.rb:5
class CanCan::ModelAdapters::ActiveRecord5Adapter < ::CanCan::ModelAdapters::ActiveRecord4Adapter
  private

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_5_adapter.rb:24
  def build_joins_relation(relation, *where_conditions); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_5_adapter.rb:33
  def sanitize_sql(conditions); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_5_adapter.rb:41
  def sanitize_sql_activerecord5(conditions); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_5_adapter.rb:28
  def strategy_class; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_5_adapter.rb:49
  def visit_nodes(node); end

  class << self
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_5_adapter.rb:8
    def for_class?(model_class); end

    # rails 5 is capable of using strings in enum
    # but often people use symbols in rules
    #
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_5_adapter.rb:14
    def matches_condition?(subject, name, value); end
  end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:5
class CanCan::ModelAdapters::ActiveRecordAdapter < ::CanCan::ModelAdapters::AbstractAdapter
  # @return [ActiveRecordAdapter] a new instance of ActiveRecordAdapter
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:16
  def initialize(model_class, rules); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:89
  def build_relation(*where_conditions); end

  # Returns the value of attribute compressed_rules.
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:14
  def compressed_rules; end

  # Returns conditions intended to be used inside a database query. Normally you will not call this
  # method directly, but instead go through ModelAdditions#accessible_by.
  #
  # If there is only one "can" definition, a hash of conditions will be returned matching the one defined.
  #
  #   can :manage, User, :id => 1
  #   query(:manage, User).conditions # => { :id => 1 }
  #
  # If there are multiple "can" definitions, a SQL string will be returned to handle complex cases.
  #
  #   can :manage, User, :id => 1
  #   can :manage, User, :manager_id => 1
  #   cannot :manage, User, :self_managed => true
  #   query(:manage, User).conditions # => "not (self_managed = 't') AND ((manager_id = 1) OR (id = 1))"
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:63
  def conditions; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:79
  def database_records; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:73
  def extract_multiple_conditions(conditions_extractor, rules); end

  # Returns the associations used in conditions for the :joins option of a search.
  # See ModelAdditions#accessible_by
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:99
  def joins; end

  private

  # Removes empty hashes and moves everything into arrays.
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:110
  def deep_clean(joins_hash); end

  # Takes two hashes and does a deep merge.
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:115
  def deep_merge(base_hash, added_hash); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:160
  def false_sql; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:140
  def merge_conditions(sql, conditions_hash, behavior); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:148
  def merge_non_empty_conditions(behavior, conditions_hash, sql); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:125
  def override_scope; end

  # @raise [Error]
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:133
  def raise_override_scope_error; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:168
  def sanitize_sql(conditions); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:164
  def true_sql; end

  class << self
    # parent_id condition can be an array of integer or one integer, we check the parent against this
    #
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:31
    def nested_subject_matches_conditions?(parent, child, all_conditions); end

    # When belongs_to parent_id is a condition for a model,
    # we want to check the parent when testing ability for a hash {parent => model}
    #
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:26
    def override_nested_subject_conditions_matching?(parent, child, all_conditions); end

    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:39
    def parent_child_conditions(parent, child, all_conditions); end

    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:6
    def version_greater_or_equal?(version); end

    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/active_record_adapter.rb:10
    def version_lower?(version); end
  end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_extractor.rb:9
class CanCan::ModelAdapters::ConditionsExtractor
  # @return [ConditionsExtractor] a new instance of ConditionsExtractor
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_extractor.rb:10
  def initialize(model_class); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_extractor.rb:15
  def tableize_conditions(conditions, model_class = T.unsafe(nil), path_to_key = T.unsafe(nil)); end

  private

  # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_extractor.rb:68
  def add_to_cache(table_alias, relation_name, path_to_key); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_extractor.rb:64
  def already_used?(table_alias, relation_name, path_to_key); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_extractor.rb:37
  def calculate_nested(model_class, result_hash, relation_name, value, path_to_key); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_extractor.rb:30
  def calculate_result_hash(key, model_class, path_to_key, result_hash, value); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_extractor.rb:50
  def generate_table_alias(model_class, relation_name, path_to_key); end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_normalizer.rb:7
class CanCan::ModelAdapters::ConditionsNormalizer
  class << self
    # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_normalizer.rb:9
    def normalize(model_class, rules); end

    # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_normalizer.rb:13
    def normalize_conditions(model_class, conditions); end

    private

    # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_normalizer.rb:28
    def calculate_result_hash(model_class, key, value); end

    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/conditions_normalizer.rb:43
    def normalizable_association?(reflection); end
  end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/default_adapter.rb:6
class CanCan::ModelAdapters::DefaultAdapter < ::CanCan::ModelAdapters::AbstractAdapter; end

# source://cancancan-3.4.0/lib/cancan/model_adapters/sti_normalizer.rb:7
class CanCan::ModelAdapters::StiNormalizer
  class << self
    # source://cancancan-3.4.0/lib/cancan/model_adapters/sti_normalizer.rb:9
    def normalize(rules); end

    private

    # create a new rule for the subclasses that links on the inheritance_column
    #
    # source://cancancan-3.4.0/lib/cancan/model_adapters/sti_normalizer.rb:32
    def build_rule_for_subclass(rule, subject); end

    # source://cancancan-3.4.0/lib/cancan/model_adapters/sti_normalizer.rb:24
    def update_rule(subject, rule, rules_cache); end
  end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:3
class CanCan::ModelAdapters::Strategies; end

# source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:4
class CanCan::ModelAdapters::Strategies::Base
  # @return [Base] a new instance of Base
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:20
  def initialize(adapter:, relation:, where_conditions:); end

  # Returns the value of attribute adapter.
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:5
  def adapter; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:26
  def aliased_table_name; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:7
  def compressed_rules(*args, &block); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:17
  def connection(*args, &block); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:7
  def extract_multiple_conditions(*args, &block); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:7
  def joins(*args, &block); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:7
  def model_class(*args, &block); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:18
  def quote_table_name(*args, &block); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:30
  def quoted_aliased_table_name; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:17
  def quoted_primary_key(*args, &block); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:34
  def quoted_table_name; end

  # Returns the value of attribute relation.
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:5
  def relation; end

  # Returns the value of attribute where_conditions.
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/base.rb:5
  def where_conditions; end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:6
class CanCan::ModelAdapters::Strategies::JoinedAliasEachRuleAsExistsSubquery < ::CanCan::ModelAdapters::Strategies::Base
  # Converts an array like [:child, :grand_child] into a hash like {child: {grand_child: {}}
  #
  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:78
  def current_path_to_hash(current_path); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:16
  def double_exists_sql; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:7
  def execute!; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:55
  def extra_joins_recursive(current_path, conditions, joins, left_joins); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:67
  def extra_joins_recursive_merge_joins(current_path, value, joins, left_joins); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:47
  def extract_joins_from_rule(rule); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:27
  def sub_query_for_rule(rule); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_each_rule_as_exists_subquery.rb:34
  def sub_query_for_rules_and_join_hashes(rule_where_conditions, joins_hash, left_joins_hash); end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_exists_subquery.rb:6
class CanCan::ModelAdapters::Strategies::JoinedAliasExistsSubquery < ::CanCan::ModelAdapters::Strategies::Base
  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_exists_subquery.rb:7
  def execute!; end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/joined_alias_exists_subquery.rb:16
  def joined_alias_exists_subquery_inner_query; end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/left_join.rb:4
class CanCan::ModelAdapters::Strategies::LeftJoin < ::CanCan::ModelAdapters::Strategies::Base
  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/left_join.rb:5
  def execute!; end
end

# source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/subquery.rb:4
class CanCan::ModelAdapters::Strategies::Subquery < ::CanCan::ModelAdapters::Strategies::Base
  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/subquery.rb:9
  def build_joins_relation_subquery(where_conditions); end

  # source://cancancan-3.4.0/lib/cancan/model_adapters/strategies/subquery.rb:5
  def execute!; end
end

# This module adds the accessible_by class method to a model. It is included in the model adapters.
#
# source://cancancan-3.4.0/lib/cancan/model_additions.rb:5
module CanCan::ModelAdditions
  mixes_in_class_methods ::CanCan::ModelAdditions::ClassMethods

  class << self
    # @private
    #
    # source://cancancan-3.4.0/lib/cancan/model_additions.rb:30
    def included(base); end
  end
end

# source://cancancan-3.4.0/lib/cancan/model_additions.rb:6
module CanCan::ModelAdditions::ClassMethods
  # Returns a scope which fetches only the records that the passed ability
  # can perform a given action on. The action defaults to :index. This
  # is usually called from a controller and passed the +current_ability+.
  #
  #   @articles = Article.accessible_by(current_ability)
  #
  # Here only the articles which the user is able to read will be returned.
  # If the user does not have permission to read any articles then an empty
  # result is returned. Since this is a scope it can be combined with any
  # other scopes or pagination.
  #
  # An alternative action can optionally be passed as a second argument.
  #
  #   @articles = Article.accessible_by(current_ability, :update)
  #
  # Here only the articles which the user can update are returned.
  #
  # source://cancancan-3.4.0/lib/cancan/model_additions.rb:23
  def accessible_by(ability, action = T.unsafe(nil), strategy: T.unsafe(nil)); end
end

# Raised when behavior is not implemented, usually used in an abstract class.
#
# source://cancancan-3.4.0/lib/cancan/exceptions.rb:8
class CanCan::NotImplemented < ::CanCan::Error; end

# source://cancancan-3.4.0/lib/cancan/parameter_validators.rb:4
module CanCan::ParameterValidators
  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/parameter_validators.rb:5
  def valid_attribute_param?(attribute); end
end

# source://cancancan-3.4.0/lib/cancan/relevant.rb:4
module CanCan::Relevant
  # Matches both the action, subject, and attribute, not necessarily the conditions
  #
  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/relevant.rb:6
  def relevant?(action, subject); end

  private

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/relevant.rb:13
  def matches_action?(action); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/relevant.rb:17
  def matches_subject?(subject); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/relevant.rb:21
  def matches_subject_class?(subject); end
end

# This class is used internally and should only be called through Ability.
# it holds the information about a "can" call made on Ability and provides
# helpful methods to determine permission checking and conditions hash generation.
#
# source://cancancan-3.4.0/lib/cancan/rule.rb:11
class CanCan::Rule
  include ::CanCan::ConditionsMatcher
  include ::CanCan::Relevant
  include ::CanCan::ParameterValidators

  # The first argument when initializing is the base_behavior which is a true/false
  # value. True for "can" and false for "cannot". The next two arguments are the action
  # and subject respectively (such as :read, @project). The third argument is a hash
  # of conditions and the last one is the block passed to the "can" call.
  #
  # @raise [Error]
  # @return [Rule] a new instance of Rule
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:22
  def initialize(base_behavior, action, subject, *extra_args, &block); end

  # Returns the value of attribute actions.
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:15
  def actions; end

  # source://cancancan-3.4.0/lib/cancan/rule.rb:76
  def associations_hash(conditions = T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:15
  def attributes; end

  # source://cancancan-3.4.0/lib/cancan/rule.rb:86
  def attributes_from_conditions; end

  # Returns the value of attribute base_behavior.
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:15
  def base_behavior; end

  # Returns the value of attribute block.
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:15
  def block; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:51
  def can_rule?; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:55
  def cannot_catch_all?; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:59
  def catch_all?; end

  # Returns the value of attribute conditions.
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:15
  def conditions; end

  # Sets the attribute conditions
  #
  # @param value the value to set the attribute conditions to.
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:16
  def conditions=(_arg0); end

  # Sets the attribute expanded_actions
  #
  # @param value the value to set the attribute expanded_actions to.
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:16
  def expanded_actions=(_arg0); end

  # source://cancancan-3.4.0/lib/cancan/rule.rb:38
  def inspect; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:96
  def matches_attributes?(attribute); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:64
  def only_block?; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:68
  def only_raw_sql?; end

  # Returns the value of attribute subjects.
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:15
  def subjects; end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:72
  def with_scope?; end

  private

  # @raise [BlockAndConditionsError]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:123
  def condition_and_block_check(conditions, block, action, subject); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:105
  def matches_action?(action); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:109
  def matches_subject?(subject); end

  # @return [Boolean]
  #
  # source://cancancan-3.4.0/lib/cancan/rule.rb:113
  def matches_subject_class?(subject); end

  # source://cancancan-3.4.0/lib/cancan/rule.rb:117
  def parse_attributes_from_extra_args(args); end

  # source://cancancan-3.4.0/lib/cancan/rule.rb:130
  def wrap(object); end
end

# source://cancancan-3.4.0/lib/cancan/rules_compressor.rb:5
class CanCan::RulesCompressor
  # @return [RulesCompressor] a new instance of RulesCompressor
  #
  # source://cancancan-3.4.0/lib/cancan/rules_compressor.rb:8
  def initialize(rules); end

  # source://cancancan-3.4.0/lib/cancan/rules_compressor.rb:13
  def compress(array); end

  # Returns the value of attribute initial_rules.
  #
  # source://cancancan-3.4.0/lib/cancan/rules_compressor.rb:6
  def initial_rules; end

  # Returns the value of attribute rules_collapsed.
  #
  # source://cancancan-3.4.0/lib/cancan/rules_compressor.rb:6
  def rules_collapsed; end
end

# source://cancancan-3.4.0/lib/cancan/unauthorized_message_resolver.rb:4
module CanCan::UnauthorizedMessageResolver
  # source://cancancan-3.4.0/lib/cancan/unauthorized_message_resolver.rb:15
  def translate_subject(subject); end

  # source://cancancan-3.4.0/lib/cancan/unauthorized_message_resolver.rb:5
  def unauthorized_message(action, subject); end
end

# source://cancancan-3.4.0/lib/cancan/version.rb:4
CanCan::VERSION = T.let(T.unsafe(nil), String)

# Raised when using a wrong association name
#
# source://cancancan-3.4.0/lib/cancan/exceptions.rb:23
class CanCan::WrongAssociationName < ::CanCan::Error; end

# source://cancancan-3.4.0/lib/cancancan.rb:5
module CanCanCan; end

# source://cancancan-3.4.0/lib/cancan/sti_detector.rb:3
class StiDetector
  class << self
    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/sti_detector.rb:4
    def sti_class?(subject); end
  end
end

# This class is responsible for matching classes and their subclasses as well as
# upmatching classes to their ancestors.
# This is used to generate sti connections
#
# source://cancancan-3.4.0/lib/cancan/class_matcher.rb:6
class SubjectClassMatcher
  class << self
    # source://cancancan-3.4.0/lib/cancan/class_matcher.rb:25
    def matches_class_or_is_related(subject, sub); end

    # @return [Boolean]
    #
    # source://cancancan-3.4.0/lib/cancan/class_matcher.rb:7
    def matches_subject_class?(subjects, subject); end

    # source://cancancan-3.4.0/lib/cancan/class_matcher.rb:14
    def matching_class_check(subject, sub, has_subclasses); end
  end
end
