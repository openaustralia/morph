# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `em-http-request` gem.
# Please instead update this file by running `bin/tapioca gem em-http-request`.

# similar to EventMachine::FileStreamer, but for any IO object
#
# source://em-http-request-1.1.7/lib/em/io_streamer.rb:4
module EventMachine
  private

  def add_oneshot_timer(_arg0); end
  def attach_fd(_arg0, _arg1); end
  def attach_sd(_arg0); end
  def bind_connect_server(_arg0, _arg1, _arg2, _arg3); end
  def close_connection(_arg0, _arg1); end
  def connect_server(_arg0, _arg1); end
  def connect_unix_server(_arg0); end
  def connection_paused?(_arg0); end
  def current_time; end
  def detach_fd(_arg0); end
  def epoll; end
  def epoll=(_arg0); end
  def epoll?; end
  def get_cipher_bits(_arg0); end
  def get_cipher_name(_arg0); end
  def get_cipher_protocol(_arg0); end
  def get_comm_inactivity_timeout(_arg0); end
  def get_connection_count; end
  def get_file_descriptor(_arg0); end
  def get_heartbeat_interval; end
  def get_idle_time(_arg0); end
  def get_max_timer_count; end
  def get_peer_cert(_arg0); end
  def get_peername(_arg0); end
  def get_pending_connect_timeout(_arg0); end
  def get_proxied_bytes(_arg0); end
  def get_simultaneous_accept_count; end
  def get_sni_hostname(_arg0); end
  def get_sock_opt(_arg0, _arg1, _arg2); end
  def get_sockname(_arg0); end
  def get_subprocess_pid(_arg0); end
  def get_subprocess_status(_arg0); end
  def initialize_event_machine; end
  def invoke_popen(_arg0); end
  def is_notify_readable(_arg0); end
  def is_notify_writable(_arg0); end
  def kqueue; end
  def kqueue=(_arg0); end
  def kqueue?; end
  def library_type; end
  def num_close_scheduled; end
  def open_udp_socket(_arg0, _arg1); end
  def pause_connection(_arg0); end
  def read_keyboard; end
  def release_machine; end
  def report_connection_error_status(_arg0); end
  def resume_connection(_arg0); end
  def run_machine; end
  def run_machine_once; end
  def run_machine_without_threads; end
  def send_data(_arg0, _arg1, _arg2); end
  def send_datagram(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def send_file_data(_arg0, _arg1); end
  def set_comm_inactivity_timeout(_arg0, _arg1); end
  def set_heartbeat_interval(_arg0); end
  def set_max_timer_count(_arg0); end
  def set_notify_readable(_arg0, _arg1); end
  def set_notify_writable(_arg0, _arg1); end
  def set_pending_connect_timeout(_arg0, _arg1); end
  def set_rlimit_nofile(_arg0); end
  def set_simultaneous_accept_count(_arg0); end
  def set_sock_opt(_arg0, _arg1, _arg2, _arg3); end
  def set_timer_quantum(_arg0); end
  def set_tls_parms(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9); end
  def setuid_string(_arg0); end
  def signal_loopbreak; end
  def ssl?; end
  def start_proxy(_arg0, _arg1, _arg2, _arg3); end
  def start_tcp_server(_arg0, _arg1); end
  def start_tls(_arg0); end
  def start_unix_server(_arg0); end
  def stop; end
  def stop_proxy(_arg0); end
  def stop_tcp_server(_arg0); end
  def stopping?; end
  def unwatch_filename(_arg0); end
  def unwatch_pid(_arg0); end
  def watch_filename(_arg0); end
  def watch_pid(_arg0); end

  class << self
    # source://eventmachine-1.2.7/lib/em/callback.rb:47
    def Callback(object = T.unsafe(nil), method = T.unsafe(nil), &blk); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1563
    def _open_file_for_writing(filename, handler = T.unsafe(nil)); end

    def add_oneshot_timer(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:351
    def add_periodic_timer(*args, &block); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:291
    def add_shutdown_hook(&block); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:323
    def add_timer(*args, &block); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:741
    def attach(io, handler = T.unsafe(nil), *args, &blk); end

    def attach_fd(_arg0, _arg1); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:746
    def attach_io(io, watch_mode, handler = T.unsafe(nil), *args); end

    def attach_sd(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:541
    def attach_server(sock, handler = T.unsafe(nil), *args, &block); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:661
    def bind_connect(bind_addr, bind_port, server, port = T.unsafe(nil), handler = T.unsafe(nil), *args); end

    def bind_connect_server(_arg0, _arg1, _arg2, _arg3); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:363
    def cancel_timer(timer_or_sig); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:261
    def cleanup_machine; end

    def close_connection(_arg0, _arg1); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:631
    def connect(server, port = T.unsafe(nil), handler = T.unsafe(nil), *args, &blk); end

    def connect_server(_arg0, _arg1); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:813
    def connect_unix_domain(socketname, *args, &blk); end

    def connect_unix_server(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:955
    def connection_count; end

    def connection_paused?(_arg0); end
    def current_time; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1043
    def defer(op = T.unsafe(nil), callback = T.unsafe(nil), errback = T.unsafe(nil), &blk); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1095
    def defers_finished?; end

    def detach_fd(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1440
    def disable_proxy(from); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1430
    def enable_proxy(from, to, bufsize = T.unsafe(nil), length = T.unsafe(nil)); end

    def epoll; end
    def epoll=(_arg0); end
    def epoll?; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1363
    def error_handler(cb = T.unsafe(nil), &blk); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1463
    def event_callback(conn_binding, opcode, data); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:243
    def fork_reactor(&block); end

    def get_cipher_bits(_arg0); end
    def get_cipher_name(_arg0); end
    def get_cipher_protocol(_arg0); end
    def get_comm_inactivity_timeout(_arg0); end
    def get_connection_count; end
    def get_file_descriptor(_arg0); end
    def get_heartbeat_interval; end
    def get_idle_time(_arg0); end
    def get_max_timer_count; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:924
    def get_max_timers; end

    def get_peer_cert(_arg0); end
    def get_peername(_arg0); end
    def get_pending_connect_timeout(_arg0); end
    def get_proxied_bytes(_arg0); end
    def get_simultaneous_accept_count; end
    def get_sni_hostname(_arg0); end
    def get_sock_opt(_arg0, _arg1, _arg2); end
    def get_sockname(_arg0); end
    def get_subprocess_pid(_arg0); end
    def get_subprocess_status(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1449
    def heartbeat_interval; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1458
    def heartbeat_interval=(time); end

    def initialize_event_machine; end
    def invoke_popen(_arg0); end
    def is_notify_readable(_arg0); end
    def is_notify_writable(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1574
    def klass_from_handler(klass = T.unsafe(nil), handler = T.unsafe(nil), *args); end

    def kqueue; end
    def kqueue=(_arg0); end
    def kqueue?; end
    def library_type; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1121
    def next_tick(pr = T.unsafe(nil), &block); end

    def num_close_scheduled; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:872
    def open_datagram_socket(address, port, handler = T.unsafe(nil), *args); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1235
    def open_keyboard(handler = T.unsafe(nil), *args); end

    def open_udp_socket(_arg0, _arg1); end
    def pause_connection(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1198
    def popen(cmd, handler = T.unsafe(nil), *args); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1227
    def reactor_running?; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:79
    def reactor_thread; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:227
    def reactor_thread?; end

    def read_keyboard; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:781
    def reconnect(server, port, handler); end

    def release_machine; end
    def report_connection_error_status(_arg0); end
    def resume_connection(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:149
    def run(blk = T.unsafe(nil), tail = T.unsafe(nil), &block); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:218
    def run_block(&block); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:967
    def run_deferred_callbacks; end

    def run_machine; end
    def run_machine_once; end
    def run_machine_without_threads; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:233
    def schedule(*a, &b); end

    def send_data(_arg0, _arg1, _arg2); end
    def send_datagram(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def send_file_data(_arg0, _arg1); end
    def set_comm_inactivity_timeout(_arg0, _arg1); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1168
    def set_descriptor_table_size(n_descriptors = T.unsafe(nil)); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1149
    def set_effective_user(username); end

    def set_heartbeat_interval(_arg0); end
    def set_max_timer_count(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:917
    def set_max_timers(ct); end

    def set_notify_readable(_arg0, _arg1); end
    def set_notify_writable(_arg0, _arg1); end
    def set_pending_connect_timeout(_arg0, _arg1); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:902
    def set_quantum(mills); end

    def set_rlimit_nofile(_arg0); end
    def set_simultaneous_accept_count(_arg0); end
    def set_sock_opt(_arg0, _arg1, _arg2, _arg3); end
    def set_timer_quantum(_arg0); end
    def set_tls_parms(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9); end
    def setuid_string(_arg0); end
    def signal_loopbreak; end

    # source://eventmachine-1.2.7/lib/em/spawnable.rb:69
    def spawn(&block); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1065
    def spawn_threadpool; end

    def ssl?; end
    def start_proxy(_arg0, _arg1, _arg2, _arg3); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:517
    def start_server(server, port = T.unsafe(nil), handler = T.unsafe(nil), *args, &block); end

    def start_tcp_server(_arg0, _arg1); end
    def start_tls(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:561
    def start_unix_domain_server(filename, *args, &block); end

    def start_unix_server(_arg0); end
    def stop; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:417
    def stop_event_loop; end

    def stop_proxy(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:551
    def stop_server(signature); end

    def stop_tcp_server(_arg0); end
    def stopping?; end

    # source://eventmachine-1.2.7/lib/em/processes.rb:112
    def system(cmd, *args, &cb); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1105
    def threadpool; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1109
    def threadpool_size; end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1109
    def threadpool_size=(_arg0); end

    # source://eventmachine-1.2.7/lib/em/tick_loop.rb:3
    def tick_loop(*a, &b); end

    def unwatch_filename(_arg0); end
    def unwatch_pid(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:731
    def watch(io, handler = T.unsafe(nil), *args, &blk); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1309
    def watch_file(filename, handler = T.unsafe(nil), *args); end

    def watch_filename(_arg0); end
    def watch_pid(_arg0); end

    # source://eventmachine-1.2.7/lib/eventmachine.rb:1340
    def watch_process(pid, handler = T.unsafe(nil), *args); end

    # source://eventmachine-1.2.7/lib/em/spawnable.rb:76
    def yield(&block); end

    # source://eventmachine-1.2.7/lib/em/spawnable.rb:81
    def yield_and_notify(&block); end
  end
end

EventMachine::ConnectionAccepted = T.let(T.unsafe(nil), Integer)
EventMachine::ConnectionCompleted = T.let(T.unsafe(nil), Integer)
EventMachine::ConnectionData = T.let(T.unsafe(nil), Integer)
class EventMachine::ConnectionError < ::RuntimeError; end
class EventMachine::ConnectionNotBound < ::RuntimeError; end
EventMachine::ConnectionNotifyReadable = T.let(T.unsafe(nil), Integer)
EventMachine::ConnectionNotifyWritable = T.let(T.unsafe(nil), Integer)
EventMachine::ConnectionUnbound = T.let(T.unsafe(nil), Integer)
EventMachine::EM_PROTO_SSLv2 = T.let(T.unsafe(nil), Integer)
EventMachine::EM_PROTO_SSLv3 = T.let(T.unsafe(nil), Integer)
EventMachine::EM_PROTO_TLSv1 = T.let(T.unsafe(nil), Integer)
EventMachine::EM_PROTO_TLSv1_1 = T.let(T.unsafe(nil), Integer)
EventMachine::EM_PROTO_TLSv1_2 = T.let(T.unsafe(nil), Integer)

# source://eventmachine-1.2.7/lib/eventmachine.rb:90
EventMachine::ERRNOS = T.let(T.unsafe(nil), Hash)

# source://em-http-request-1.1.7/lib/em-http/http_connection.rb:5
module EventMachine::HTTPMethods
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:8
  def delete(options = T.unsafe(nil), &blk); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:6
  def get(options = T.unsafe(nil), &blk); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:7
  def head(options = T.unsafe(nil), &blk); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:12
  def options(options = T.unsafe(nil), &blk); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:11
  def patch(options = T.unsafe(nil), &blk); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:10
  def post(options = T.unsafe(nil), &blk); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:9
  def put(options = T.unsafe(nil), &blk); end
end

# source://em-http-request-1.1.7/lib/em-http/client.rb:6
class EventMachine::HttpClient
  include ::EventMachine::Deferrable
  include ::EventMachine::HttpEncoding
  include ::EventMachine::HttpStatus

  # @return [HttpClient] a new instance of HttpClient
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:27
  def initialize(conn, options); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:134
  def build_request; end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:121
  def close(msg = T.unsafe(nil)); end

  # Returns the value of attribute conn.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:24
  def conn; end

  # Sets the attribute conn
  #
  # @param value the value to set the attribute conn to.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:24
  def conn=(_arg0); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:53
  def connection_completed; end

  # Returns the value of attribute content_charset.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:25
  def content_charset; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:74
  def continue?; end

  # Returns the value of attribute cookies.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:25
  def cookies; end

  # Returns the value of attribute error.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:25
  def error; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:78
  def finished?; end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:128
  def headers(&blk); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:49
  def last_effective_url; end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:130
  def normalize_body(body); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:205
  def on_body_data(data); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:217
  def on_decoded_body_data(data); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:121
  def on_error(msg = T.unsafe(nil)); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:64
  def on_request_complete; end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:248
  def parse_response_header(header, version, status); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:51
  def peer; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:82
  def redirect?; end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:50
  def redirects; end

  # Returns the value of attribute req.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:25
  def req; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:226
  def request_body_pending?; end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:39
  def reset!; end

  # Returns the value of attribute response.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:24
  def response; end

  # Sets the attribute response
  #
  # @param value the value to set the attribute response to.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:24
  def response=(_arg0); end

  # Returns the value of attribute response_header.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:25
  def response_header; end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:174
  def send_request(head, body); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:230
  def send_request_body; end

  # Returns the value of attribute state.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:24
  def state; end

  # Sets the attribute state
  #
  # @param value the value to set the attribute state to.
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:24
  def state=(_arg0); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:127
  def stream(&blk); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:86
  def unbind(reason = T.unsafe(nil)); end
end

# source://em-http-request-1.1.7/lib/em-http/client.rb:12
EventMachine::HttpClient::CONTENT_ENCODING = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:13
EventMachine::HttpClient::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:14
EventMachine::HttpClient::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:22
EventMachine::HttpClient::CRLF = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:326
class EventMachine::HttpClient::CookieJar
  # @return [CookieJar] a new instance of CookieJar
  #
  # source://em-http-request-1.1.7/lib/em-http/client.rb:327
  def initialize; end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:335
  def get(uri); end

  # source://em-http-request-1.1.7/lib/em-http/client.rb:331
  def set(string, uri); end
end

# source://em-http-request-1.1.7/lib/em-http/client.rb:20
EventMachine::HttpClient::ETAG = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:19
EventMachine::HttpClient::HOST = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:16
EventMachine::HttpClient::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:15
EventMachine::HttpClient::LAST_MODIFIED = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:18
EventMachine::HttpClient::LOCATION = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:17
EventMachine::HttpClient::SET_COOKIE = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/client.rb:11
EventMachine::HttpClient::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/http_connection.rb:97
class EventMachine::HttpConnection
  include ::EventMachine::HTTPMethods
  include ::EventMachine::Socksify
  include ::EventMachine::Connectify

  # @return [HttpConnection] a new instance of HttpConnection
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:105
  def initialize; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:115
  def activate_connection(client); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:272
  def close(reason = T.unsafe(nil)); end

  # Returns the value of attribute conn.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:102
  def conn; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:110
  def conn=(c); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:226
  def connection_completed; end

  # Returns the value of attribute connopts.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:103
  def connopts; end

  # Sets the attribute connopts
  #
  # @param value the value to set the attribute connopts to.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:103
  def connopts=(_arg0); end

  # Returns the value of attribute deferred.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:102
  def deferred; end

  # Returns the value of attribute error.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:103
  def error; end

  # Sets the attribute error
  #
  # @param value the value to set the attribute error to.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:103
  def error=(_arg0); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:158
  def finalize_request(c); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:168
  def middleware; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:213
  def peer; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:172
  def post_init; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:217
  def receive_data(data); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:243
  def redirect(client, new_location); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:303
  def send_data(data); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:152
  def setup_request(method, options = T.unsafe(nil), c = T.unsafe(nil)); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:238
  def start; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:311
  def stream_data(io, opts = T.unsafe(nil)); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:307
  def stream_file_data(filename, args = T.unsafe(nil)); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:272
  def unbind(reason = T.unsafe(nil)); end

  # Returns the value of attribute uri.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:103
  def uri; end

  # Sets the attribute uri
  #
  # @param value the value to set the attribute uri to.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:103
  def uri=(_arg0); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:209
  def use(klass, *args, &block); end

  private

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:317
  def client; end
end

# Provides a unified callback interface to decompression libraries.
#
# source://em-http-request-1.1.7/lib/em-http/decoders.rb:6
module EventMachine::HttpDecoders
  class << self
    # source://em-http-request-1.1.7/lib/em-http/decoders.rb:12
    def accepted_encodings; end

    # source://em-http-request-1.1.7/lib/em-http/decoders.rb:16
    def decoder_for_encoding(encoding); end
  end
end

# source://em-http-request-1.1.7/lib/em-http/decoders.rb:24
class EventMachine::HttpDecoders::Base
  # chunk_callback:: [Block] To handle a decompressed chunk
  #
  # @return [Base] a new instance of Base
  #
  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:32
  def initialize(&chunk_callback); end

  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:36
  def <<(compressed); end

  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:43
  def finalize!; end

  protected

  # Must return a part of decompressed
  #
  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:60
  def decompress(compressed); end

  # May return last part
  #
  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:66
  def finalize; end

  private

  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:50
  def receive_decompressed(decompressed); end

  class << self
    # source://em-http-request-1.1.7/lib/em-http/decoders.rb:25
    def encoding_names; end
  end
end

# source://em-http-request-1.1.7/lib/em-http/decoders.rb:250
EventMachine::HttpDecoders::DECODERS = T.let(T.unsafe(nil), Array)

# source://em-http-request-1.1.7/lib/em-http/decoders.rb:8
class EventMachine::HttpDecoders::DecoderError < ::StandardError; end

# source://em-http-request-1.1.7/lib/em-http/decoders.rb:71
class EventMachine::HttpDecoders::Deflate < ::EventMachine::HttpDecoders::Base
  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:72
  def decompress(compressed); end

  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:81
  def finalize; end
end

# source://em-http-request-1.1.7/lib/em-http/decoders.rb:217
class EventMachine::HttpDecoders::GZip < ::EventMachine::HttpDecoders::Base
  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:222
  def decompress(compressed); end

  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:234
  def finalize; end

  class << self
    # source://em-http-request-1.1.7/lib/em-http/decoders.rb:218
    def encoding_names; end
  end
end

# Partial implementation of RFC 1952 to extract the deflate stream from a gzip file
#
# source://em-http-request-1.1.7/lib/em-http/decoders.rb:96
class EventMachine::HttpDecoders::GZipHeader
  # @return [GZipHeader] a new instance of GZipHeader
  #
  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:97
  def initialize; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:124
  def eof?; end

  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:128
  def extract_stream(compressed); end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:103
  def finished?; end

  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:107
  def read(n, buffer); end

  # source://em-http-request-1.1.7/lib/em-http/decoders.rb:117
  def readbyte; end
end

# source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:2
module EventMachine::HttpEncoding
  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:27
  def bytesize(string); end

  # Encode basic auth in an HTTP header
  # In: Array ([user, pass]) - for basic auth
  #     String - custom auth string (OAuth, etc)
  #
  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:120
  def encode_auth(k, v); end

  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:141
  def encode_cookie(cookie); end

  # Encode a field in an HTTP header
  #
  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:113
  def encode_field(k, v); end

  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:128
  def encode_headers(head); end

  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:41
  def encode_host; end

  # URL encodes query parameters:
  # single k=v, or a URL encoded array, if v is an array of values
  #
  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:81
  def encode_param(k, v); end

  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:66
  def encode_query(uri, query); end

  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:49
  def encode_request(method, uri, query, connopts); end

  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:6
  def escape(s); end

  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:89
  def form_encode_body(obj); end

  # Map all header keys to a downcased string version
  #
  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:37
  def munge_header_keys(head); end

  # source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:16
  def unescape(s); end
end

# source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:4
EventMachine::HttpEncoding::FIELD_ENCODING = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/http_encoding.rb:3
EventMachine::HttpEncoding::HTTP_REQUEST_HEADER = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/request.rb:2
class EventMachine::HttpRequest
  class << self
    # source://em-http-request-1.1.7/lib/em-http/request.rb:19
    def middleware; end

    # source://em-http-request-1.1.7/lib/em-http/request.rb:5
    def new(uri, options = T.unsafe(nil)); end

    # source://em-http-request-1.1.7/lib/em-http/request.rb:15
    def use(klass, *args, &block); end
  end
end

# source://em-http-request-1.1.7/lib/em-http/version.rb:3
EventMachine::HttpRequest::VERSION = T.let(T.unsafe(nil), String)

# A simple hash is returned for each request made by HttpClient with the
# headers that were given by the server for that request.
#
# source://em-http-request-1.1.7/lib/em-http/http_header.rb:5
class EventMachine::HttpResponseHeader < ::Hash
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:59
  def [](key); end

  # Is the transfer encoding chunked?
  #
  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:43
  def chunked_encoding?; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:75
  def client_error?; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:51
  def compressed?; end

  # Length of content as an integer, or nil if chunked/unspecified
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:32
  def content_length; end

  # Cookie header from the server
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:38
  def cookie; end

  # E-Tag
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:18
  def etag; end

  # The reason returned in the http response (string - e.g. "OK")
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:6
  def http_reason; end

  # The reason returned in the http response (string - e.g. "OK")
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:6
  def http_reason=(_arg0); end

  # The status code (integer - e.g. 200)
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:12
  def http_status; end

  # The status code (integer - e.g. 200)
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:12
  def http_status=(_arg0); end

  # The HTTP version returned (string - e.g. "1.1")
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:9
  def http_version; end

  # The HTTP version returned (string - e.g. "1.1")
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:9
  def http_version=(_arg0); end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:63
  def informational?; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:47
  def keepalive?; end

  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:22
  def last_modified; end

  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:55
  def location; end

  # Raw headers
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:15
  def raw; end

  # Raw headers
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:15
  def raw=(_arg0); end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:71
  def redirection?; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:79
  def server_error?; end

  # HTTP response status
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:27
  def status; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_header.rb:67
  def successful?; end
end

# source://em-http-request-1.1.7/lib/em-http/http_status_codes.rb:2
module EventMachine::HttpStatus; end

# source://em-http-request-1.1.7/lib/em-http/http_status_codes.rb:3
EventMachine::HttpStatus::CODE = T.let(T.unsafe(nil), Hash)

# source://em-http-request-1.1.7/lib/em-http/http_connection.rb:15
class EventMachine::HttpStubConnection < ::EventMachine::Connection
  include ::EventMachine::Deferrable

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:86
  def certificate_store; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:32
  def connection_completed; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:82
  def host; end

  # Returns the value of attribute parent.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:17
  def parent; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:19
  def parent=(p); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:24
  def receive_data(data); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:64
  def ssl_handshake_completed; end

  # TLS verification support, original implementation by Mislav MarohniÄ‡
  # https://github.com/lostisland/faraday/blob/63cf47c95b573539f047c729bd9ad67560bc83ff/lib/faraday/adapter/em_http_ssl_patch.rb
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:42
  def ssl_verify_peer(cert_string); end

  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:36
  def unbind(reason = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection.rb:78
  def verify_peer?; end
end

# source://em-http-request-1.1.7/lib/em/io_streamer.rb:5
class EventMachine::IOStreamer
  include ::EventMachine::Deferrable

  # @option opts
  # @param connection [EventMachine::Connection]
  # @param io [IO] Data source
  # @param Data [Integer] size
  # @param opts [Hash] a customizable set of options
  # @return [IOStreamer] a new instance of IOStreamer
  #
  # source://em-http-request-1.1.7/lib/em/io_streamer.rb:14
  def initialize(connection, io, opts = T.unsafe(nil)); end

  private

  # Used internally to stream one chunk at a time over multiple reactor ticks
  #
  # @private
  #
  # source://em-http-request-1.1.7/lib/em/io_streamer.rb:28
  def stream_one_chunk; end
end

# source://em-http-request-1.1.7/lib/em/io_streamer.rb:7
EventMachine::IOStreamer::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

class EventMachine::InvalidSignature < ::RuntimeError; end
EventMachine::LoopbreakSignalled = T.let(T.unsafe(nil), Integer)

# EventMachine based Multi request client, based on a streaming HTTPRequest class,
# which allows you to open multiple parallel connections and return only when all
# of them finish. (i.e. ideal for parallelizing workloads)
#
# == Example
#
#  EventMachine.run {
#
#    multi = EventMachine::MultiRequest.new
#
#    # add multiple requests to the multi-handler
#    multi.add(:a, EventMachine::HttpRequest.new('http://www.google.com/').get)
#    multi.add(:b, EventMachine::HttpRequest.new('http://www.yahoo.com/').get)
#
#    multi.callback {
#      p multi.responses[:callback]
#      p multi.responses[:errback]
#
#      EventMachine.stop
#    }
#  }
#
# source://em-http-request-1.1.7/lib/em-http/multi.rb:26
class EventMachine::MultiRequest
  include ::EventMachine::Deferrable

  # @return [MultiRequest] a new instance of MultiRequest
  #
  # source://em-http-request-1.1.7/lib/em-http/multi.rb:31
  def initialize; end

  # source://em-http-request-1.1.7/lib/em-http/multi.rb:36
  def add(name, conn); end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/multi.rb:45
  def finished?; end

  # Returns the value of attribute requests.
  #
  # source://em-http-request-1.1.7/lib/em-http/multi.rb:29
  def requests; end

  # Returns the value of attribute responses.
  #
  # source://em-http-request-1.1.7/lib/em-http/multi.rb:29
  def responses; end

  protected

  # invoke callback if all requests have completed
  #
  # source://em-http-request-1.1.7/lib/em-http/multi.rb:52
  def check_progress; end
end

class EventMachine::NoHandlerForAcceptedConnection < ::RuntimeError; end

# source://eventmachine-1.2.7/lib/eventmachine.rb:1601
EventMachine::P = EventMachine::Protocols

EventMachine::SslHandshakeCompleted = T.let(T.unsafe(nil), Integer)
EventMachine::SslVerify = T.let(T.unsafe(nil), Integer)
EventMachine::TimerFired = T.let(T.unsafe(nil), Integer)
class EventMachine::UnknownTimerFired < ::RuntimeError; end
class EventMachine::Unsupported < ::RuntimeError; end

# source://eventmachine-1.2.7/lib/em/version.rb:2
EventMachine::VERSION = T.let(T.unsafe(nil), String)

# source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:1
class HttpClientOptions
  # @return [HttpClientOptions] a new instance of HttpClientOptions
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:8
  def initialize(uri, options, method); end

  # Returns the value of attribute body.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:3
  def body; end

  # Returns the value of attribute compressed.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:4
  def compressed; end

  # Returns the value of attribute decoding.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:4
  def decoding; end

  # Returns the value of attribute file.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:3
  def file; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:26
  def follow_redirect?; end

  # Returns the value of attribute followed.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:6
  def followed; end

  # Sets the attribute followed
  #
  # @param value the value to set the attribute followed to.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:6
  def followed=(_arg0); end

  # Returns the value of attribute headers.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:3
  def headers; end

  # Returns the value of attribute host.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:2
  def host; end

  # Returns the value of attribute keepalive.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:4
  def keepalive; end

  # Returns the value of attribute method.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:2
  def method; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:28
  def no_body?; end

  # Returns the value of attribute pass_cookies.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:4
  def pass_cookies; end

  # Returns the value of attribute path.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:3
  def path; end

  # Returns the value of attribute port.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:2
  def port; end

  # Returns the value of attribute query.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:3
  def query; end

  # Returns the value of attribute redirects.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:6
  def redirects; end

  # Sets the attribute redirects
  #
  # @param value the value to set the attribute redirects to.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:6
  def redirects=(_arg0); end

  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:30
  def set_uri(uri, path = T.unsafe(nil), query = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:27
  def ssl?; end

  # Returns the value of attribute uri.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_client_options.rb:2
  def uri; end
end

# source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:1
class HttpConnectionOptions
  # @return [HttpConnectionOptions] a new instance of HttpConnectionOptions
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:6
  def initialize(uri, options); end

  # Returns the value of attribute bind.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:2
  def bind; end

  # Returns the value of attribute bind_port.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:2
  def bind_port; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:40
  def connect_proxy?; end

  # Returns the value of attribute connect_timeout.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:3
  def connect_timeout; end

  # Returns the value of attribute host.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:2
  def host; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:36
  def http_proxy?; end

  # Sets the attribute https
  #
  # @param value the value to set the attribute https to.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:4
  def https=(_arg0); end

  # Returns the value of attribute inactivity_timeout.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:3
  def inactivity_timeout; end

  # Returns the value of attribute port.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:2
  def port; end

  # Returns the value of attribute proxy.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:2
  def proxy; end

  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:48
  def proxy_from_env; end

  # @return [Boolean]
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:44
  def socks_proxy?; end

  # Returns the value of attribute tls.
  #
  # source://em-http-request-1.1.7/lib/em-http/http_connection_options.rb:2
  def tls; end
end
