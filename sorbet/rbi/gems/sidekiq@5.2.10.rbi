# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq`.

# source://sidekiq-5.2.10/lib/sidekiq/version.rb:2
module Sidekiq
  class << self
    # How frequently Redis should be checked by a random Sidekiq process for
    # scheduled and retriable jobs. Each individual process will take turns by
    # waiting some multiple of this value.
    #
    # See sidekiq/scheduled.rb for an in-depth explanation of this value
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:199
    def average_scheduled_poll_interval=(interval); end

    # @yield [@client_chain]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:137
    def client_middleware; end

    # Configuration for Sidekiq client, use like:
    #
    #   Sidekiq.configure_client do |config|
    #     config.redis = { :namespace => 'myapp', :size => 1, :url => 'redis://myhost:8877/0' }
    #   end
    #
    # @yield [_self]
    # @yieldparam _self [Sidekiq] the object that the method was called on
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:84
    def configure_client; end

    # Configuration for Sidekiq server, use like:
    #
    #   Sidekiq.configure_server do |config|
    #     config.redis = { :namespace => 'myapp', :size => 25, :url => 'redis://myhost:8877/0' }
    #     config.server_middleware do |chain|
    #       chain.add MyServerHook
    #     end
    #   end
    #
    # @yield [_self]
    # @yieldparam _self [Sidekiq] the object that the method was called on
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:74
    def configure_server; end

    # Death handlers are called when all retries for a job have been exhausted and
    # the job dies.  It's the notification to your application
    # that this job will not succeed without manual intervention.
    #
    # Sidekiq.configure_server do |config|
    #   config.death_handlers << ->(job, ex) do
    #   end
    # end
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:176
    def death_handlers; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:161
    def default_retries_exhausted=(prok); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:149
    def default_server_middleware; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:157
    def default_worker_options; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:153
    def default_worker_options=(hash); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:183
    def dump_json(object); end

    # Register a proc to handle any error which occurs within the Sidekiq process.
    #
    #   Sidekiq.configure_server do |config|
    #     config.error_handlers << proc {|ex,ctx_hash| MyErrorService.notify(ex, ctx_hash) }
    #   end
    #
    # The default error handler logs errors to Sidekiq.logger.
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:210
    def error_handlers; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:180
    def load_json(string); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:187
    def logger; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:190
    def logger=(log); end

    # Register a block to run at a point in the Sidekiq lifecycle.
    # :startup, :quiet or :shutdown are valid events.
    #
    #   Sidekiq.configure_server do |config|
    #     config.on(:shutdown) do
    #       puts "Goodbye cruel world!"
    #     end
    #   end
    #
    # @raise [ArgumentError]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:222
    def on(event, &block); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:57
    def options; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:61
    def options=(opts); end

    # @raise [ArgumentError]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:92
    def redis; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:129
    def redis=(hash); end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:107
    def redis_info; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:125
    def redis_pool; end

    # @return [Boolean]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:88
    def server?; end

    # @yield [@server_chain]
    #
    # source://sidekiq-5.2.10/lib/sidekiq.rb:143
    def server_middleware; end

    # source://sidekiq-5.2.10/lib/sidekiq.rb:53
    def â¨â•¯Â°â–¡Â°â©â•¯ï¸µâ”»â”â”»; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:5
class Sidekiq::BasicFetch
  # @return [BasicFetch] a new instance of BasicFetch
  #
  # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:26
  def initialize(options); end

  # Creating the Redis#brpop command takes into account any
  # configured queue weights. By default Redis#brpop returns
  # data from the first queue that has pending elements. We
  # recreate the queue command each time we invoke Redis#brpop
  # to honor weights and avoid queue starvation.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:45
  def queues_cmd; end

  # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:35
  def retrieve_work; end

  class << self
    # By leaving this as a class method, it can be pluggable and used by the Manager actor. Making it
    # an instance method will make it async to the Fetcher actor
    #
    # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:58
    def bulk_requeue(inprogress, options); end
  end
end

# We want the fetch operation to timeout every few seconds so the thread
# can check if the process is shutting down.
#
# source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:8
Sidekiq::BasicFetch::TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:10
class Sidekiq::BasicFetch::UnitOfWork < ::Struct
  # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:11
  def acknowledge; end

  # Returns the value of attribute job
  #
  # @return [Object] the current value of job
  def job; end

  # Sets the attribute job
  #
  # @param value [Object] the value to set the attribute job to.
  # @return [Object] the newly set value
  #
  # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:10
  def job=(_); end

  # Returns the value of attribute queue
  #
  # @return [Object] the current value of queue
  def queue; end

  # Sets the attribute queue
  #
  # @param value [Object] the value to set the attribute queue to.
  # @return [Object] the newly set value
  #
  # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:10
  def queue=(_); end

  # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:15
  def queue_name; end

  # source://sidekiq-5.2.10/lib/sidekiq/fetch.rb:19
  def requeue; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/cli.rb:15
class Sidekiq::CLI
  include ::Sidekiq::ExceptionHandler
  include ::Sidekiq::Util
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # Returns the value of attribute environment.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:28
  def environment; end

  # Sets the attribute environment
  #
  # @param value the value to set the attribute environment to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:28
  def environment=(_arg0); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:172
  def handle_signal(sig); end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:36
  def jruby?; end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:99
  def launch(self_read); end

  # Returns the value of attribute launcher.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:27
  def launcher; end

  # Sets the attribute launcher
  #
  # @param value the value to set the attribute launcher to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:27
  def launcher=(_arg0); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:30
  def parse(args = T.unsafe(nil)); end

  # Code within this method is not tested because it alters
  # global process state irreversibly.  PRs which improve the
  # test coverage of Sidekiq::CLI are welcomed.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:43
  def run; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:270
  def boot_system; end

  # @raise [ArgumentError]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:190
  def daemonize; end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:296
  def default_tag; end

  def die(*_arg0); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:398
  def initialize_logger; end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:266
  def options; end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:413
  def parse_config(path); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:323
  def parse_options(argv); end

  # @raise [ArgumentError]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:438
  def parse_queue(opts, queue, weight = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:434
  def parse_queues(opts, queues_and_weights); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:184
  def print_banner; end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:215
  def set_environment(cli_env); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:230
  def setup_options(args); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:219
  def symbolize_keys_deep!(hash); end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:307
  def validate!; end

  # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:404
  def write_pid; end

  def â˜ (*_arg0); end

  class << self
    # source://sidekiq-5.2.10/lib/sidekiq/cli.rb:123
    def banner; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/cli.rb:19
Sidekiq::CLI::PROCTITLES = T.let(T.unsafe(nil), Array)

# source://sidekiq-5.2.10/lib/sidekiq/cli.rb:140
Sidekiq::CLI::SIGNAL_HANDLERS = T.let(T.unsafe(nil), Hash)

# source://sidekiq-5.2.10/lib/sidekiq/client.rb:6
class Sidekiq::Client
  include ::Sidekiq::TestingClient

  # Sidekiq::Client normally uses the default Redis pool but you may
  # pass a custom ConnectionPool if you want to shard your
  # Sidekiq jobs across several Redis instances (for scalability
  # reasons, e.g.)
  #
  #   Sidekiq::Client.new(ConnectionPool.new { Redis.new })
  #
  # Generally this is only needed for very large Sidekiq installs processing
  # thousands of jobs per second.  I don't recommend sharding unless you
  # cannot scale any other way (e.g. splitting your app into smaller apps).
  #
  # @return [Client] a new instance of Client
  #
  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:41
  def initialize(redis_pool = T.unsafe(nil)); end

  # Define client-side middleware:
  #
  #   client = Sidekiq::Client.new
  #   client.middleware do |chain|
  #     chain.use MyClientMiddleware
  #   end
  #   client.push('class' => 'SomeWorker', 'args' => [1,2,3])
  #
  # All client instances default to the globally-defined
  # Sidekiq.client_middleware but you can change as necessary.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:20
  def middleware(&block); end

  # The main method used to push a job to Redis.  Accepts a number of options:
  #
  #   queue - the named queue to use, default 'default'
  #   class - the worker class to call, required
  #   args - an array of simple arguments to the perform method, must be JSON-serializable
  #   at - timestamp to schedule the job (optional), must be Numeric (e.g. Time.now.to_f)
  #   retry - whether to retry this job if it fails, default true or an integer number of retries
  #   backtrace - whether to save any error backtrace, default false
  #
  # If class is set to the class name, the jobs' options will be based on Sidekiq's default
  # worker options. Otherwise, they will be based on the job class's options.
  #
  # Any options valid for a worker class's sidekiq_options are also available here.
  #
  # All options must be strings, not symbols.  NB: because we are serializing to JSON, all
  # symbols in 'args' will be converted to strings.  Note that +backtrace: true+ can take quite a bit of
  # space in Redis; a large volume of failing jobs can start Redis swapping if you aren't careful.
  #
  # Returns a unique Job ID.  If middleware stops the job, nil will be returned instead.
  #
  # Example:
  #   push('queue' => 'my_queue', 'class' => MyWorker, 'args' => ['foo', 1, :bat => 'bar'])
  #
  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:69
  def push(item); end

  # Push a large number of jobs to Redis. This method cuts out the redis
  # network round trip latency.  I wouldn't recommend pushing more than
  # 1000 per call but YMMV based on network quality, size of job args, etc.
  # A large number of jobs can cause a bit of Redis command processing latency.
  #
  # Takes the same arguments as #push except that args is expected to be
  # an Array of Arrays.  All other keys are duplicated for each job.  Each job
  # is run through the client middleware pipeline and each job gets its own Job ID
  # as normal.
  #
  # Returns an array of the of pushed jobs' jids.  The number of jobs pushed can be less
  # than the number given if the middleware stopped processing for one or more jobs.
  #
  # @raise [ArgumentError]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:92
  def push_bulk(items); end

  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:76
  def raw_push(payloads); end

  # Returns the value of attribute redis_pool.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:29
  def redis_pool; end

  # Sets the attribute redis_pool
  #
  # @param value the value to set the attribute redis_pool to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:29
  def redis_pool=(_arg0); end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:191
  def atomic_push(conn, payloads); end

  # @raise [ArgumentError]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:217
  def normalize_item(item); end

  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:234
  def normalized_hash(item_class); end

  # source://sidekiq-5.2.10/lib/sidekiq/client.rb:209
  def process_single(worker_class, item); end

  class << self
    # Resque compatibility helpers.  Note all helpers
    # should go through Worker#client_push.
    #
    # Example usage:
    #   Sidekiq::Client.enqueue(MyWorker, 'foo', 1, :bat => 'bar')
    #
    # Messages are enqueued to the 'default' queue.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/client.rb:147
    def enqueue(klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_in(3.minutes, MyWorker, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq-5.2.10/lib/sidekiq/client.rb:175
    def enqueue_in(interval, klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_to(:queue_name, MyWorker, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq-5.2.10/lib/sidekiq/client.rb:154
    def enqueue_to(queue, klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_to_in(:queue_name, 3.minutes, MyWorker, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq-5.2.10/lib/sidekiq/client.rb:161
    def enqueue_to_in(queue, interval, klass, *args); end

    # source://sidekiq-5.2.10/lib/sidekiq/client.rb:131
    def push(item); end

    # source://sidekiq-5.2.10/lib/sidekiq/client.rb:135
    def push_bulk(items); end

    # Allows sharding of jobs across any number of Redis instances.  All jobs
    # defined within the block will use the given Redis connection pool.
    #
    #   pool = ConnectionPool.new { Redis.new }
    #   Sidekiq::Client.via(pool) do
    #     SomeWorker.perform_async(1,2,3)
    #     SomeOtherWorker.perform_async(1,2,3)
    #   end
    #
    # Generally this is only needed for very large Sidekiq installs processing
    # thousands of jobs per second.  I do not recommend sharding unless
    # you cannot scale any other way (e.g. splitting your app into smaller apps).
    #
    # source://sidekiq-5.2.10/lib/sidekiq/client.rb:120
    def via(pool); end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq.rb:18
Sidekiq::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://sidekiq-5.2.10/lib/sidekiq.rb:40
Sidekiq::DEFAULT_WORKER_OPTIONS = T.let(T.unsafe(nil), Hash)

# Allows enumeration of dead jobs within Sidekiq.
#
# source://sidekiq-5.2.10/lib/sidekiq/api.rb:686
class Sidekiq::DeadSet < ::Sidekiq::JobSet
  # @return [DeadSet] a new instance of DeadSet
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:687
  def initialize; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:691
  def kill(message, opts = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:712
  def retry_all; end

  class << self
    # source://sidekiq-5.2.10/lib/sidekiq/api.rb:718
    def max_jobs; end

    # source://sidekiq-5.2.10/lib/sidekiq/api.rb:722
    def timeout; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/testing.rb:73
class Sidekiq::EmptyQueueError < ::RuntimeError; end

# source://sidekiq-5.2.10/lib/sidekiq/exception_handler.rb:5
module Sidekiq::ExceptionHandler
  # source://sidekiq-5.2.10/lib/sidekiq/exception_handler.rb:17
  def handle_exception(ex, ctxHash = T.unsafe(nil)); end
end

# source://sidekiq-5.2.10/lib/sidekiq/exception_handler.rb:7
class Sidekiq::ExceptionHandler::Logger
  # source://sidekiq-5.2.10/lib/sidekiq/exception_handler.rb:8
  def call(ex, ctxHash); end
end

# source://sidekiq-5.2.10/lib/sidekiq/delay.rb:3
module Sidekiq::Extensions
  class << self
    # source://sidekiq-5.2.10/lib/sidekiq/delay.rb:5
    def enable_delay!; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/delay.rb:26
module Sidekiq::Extensions::PsychAutoload
  # source://sidekiq-5.2.10/lib/sidekiq/delay.rb:27
  def resolve_class(klass_name); end
end

# source://sidekiq-5.2.10/lib/sidekiq.rb:45
Sidekiq::FAKE_INFO = T.let(T.unsafe(nil), Hash)

# Encapsulates a pending job within a Sidekiq queue or
# sorted set.
#
# The job should be considered immutable but may be
# removed from the queue via Job#delete.
#
# source://sidekiq-5.2.10/lib/sidekiq/api.rb:316
class Sidekiq::Job
  # @return [Job] a new instance of Job
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:320
  def initialize(item, queue_name = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:420
  def [](name); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:386
  def args; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:398
  def created_at; end

  # Remove this job from the queue.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:413
  def delete; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:362
  def display_args; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:342
  def display_class; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:394
  def enqueued_at; end

  # Returns the value of attribute item.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:317
  def item; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:390
  def jid; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:338
  def klass; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:406
  def latency; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:327
  def parse(item); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:402
  def queue; end

  # Returns the value of attribute value.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:318
  def value; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:429
  def safe_load(content, default); end
end

# source://sidekiq-5.2.10/lib/sidekiq/job_logger.rb:3
class Sidekiq::JobLogger
  # source://sidekiq-5.2.10/lib/sidekiq/job_logger.rb:5
  def call(item, queue); end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/job_logger.rb:17
  def elapsed(start); end

  # source://sidekiq-5.2.10/lib/sidekiq/job_logger.rb:21
  def logger; end
end

# Automatically retry jobs that fail in Sidekiq.
# Sidekiq's retry support assumes a typical development lifecycle:
#
#   0. Push some code changes with a bug in it.
#   1. Bug causes job processing to fail, Sidekiq's middleware captures
#      the job and pushes it onto a retry queue.
#   2. Sidekiq retries jobs in the retry queue multiple times with
#      an exponential delay, the job continues to fail.
#   3. After a few days, a developer deploys a fix. The job is
#      reprocessed successfully.
#   4. Once retries are exhausted, Sidekiq will give up and move the
#      job to the Dead Job Queue (aka morgue) where it must be dealt with
#      manually in the Web UI.
#   5. After 6 months on the DJQ, Sidekiq will discard the job.
#
# A job looks like:
#
#     { 'class' => 'HardWorker', 'args' => [1, 2, 'foo'], 'retry' => true }
#
# The 'retry' option also accepts a number (in place of 'true'):
#
#     { 'class' => 'HardWorker', 'args' => [1, 2, 'foo'], 'retry' => 5 }
#
# The job will be retried this number of times before giving up. (If simply
# 'true', Sidekiq retries 25 times)
#
# We'll add a bit more data to the job to support retries:
#
#  * 'queue' - the queue to use
#  * 'retry_count' - number of times we've retried so far.
#  * 'error_message' - the message from the exception
#  * 'error_class' - the exception class
#  * 'failed_at' - the first time it failed
#  * 'retried_at' - the last time it was retried
#  * 'backtrace' - the number of lines of error backtrace to store
#
# We don't store the backtrace by default as that can add a lot of overhead
# to the job and everyone is using an error service, right?
#
# The default number of retries is 25 which works out to about 3 weeks
# You can change the default maximum number of retries in your initializer:
#
#   Sidekiq.options[:max_retries] = 7
#
# or limit the number of retries for a particular worker with:
#
#    class MyWorker
#      include Sidekiq::Worker
#      sidekiq_options :retry => 10
#    end
#
# source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:58
class Sidekiq::JobRetry
  include ::Sidekiq::ExceptionHandler
  include ::Sidekiq::Util

  # @return [JobRetry] a new instance of JobRetry
  #
  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:66
  def initialize(options = T.unsafe(nil)); end

  # The global retry handler requires only the barest of data.
  # We want to be able to retry as much as possible so we don't
  # require the worker to be instantiated.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:73
  def global(msg, queue); end

  # The local retry support means that any errors that occur within
  # this block can be associated with the given worker instance.
  # This is required to support the `sidekiq_retries_exhausted` block.
  #
  # Note that any exception from the block is wrapped in the Skip
  # exception so the global block does not reprocess the error.  The
  # Skip exception is unwrapped within Sidekiq::Processor#process before
  # calling the handle_exception handlers.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:108
  def local(worker, msg, queue); end

  private

  # Note that +worker+ can be nil here if an error is raised before we can
  # instantiate the worker instance.  All access must be guarded and
  # best effort.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:135
  def attempt_retry(worker, msg, queue, exception); end

  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:216
  def delay_for(worker, count, exception); end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:238
  def exception_caused_by_shutdown?(e, checked_causes = T.unsafe(nil)); end

  # Extract message from exception.
  # Set a default if the message raises an error
  #
  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:251
  def exception_message(exception); end

  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:183
  def retries_exhausted(worker, msg, exception); end

  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:208
  def retry_attempts_from(msg_retry, default); end

  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:229
  def retry_in(worker, count, exception); end

  # delayed_job uses the same basic formula
  #
  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:225
  def seconds_to_delay(count); end

  # source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:202
  def send_to_morgue(msg); end
end

# source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:64
Sidekiq::JobRetry::DEFAULT_MAX_RETRY_ATTEMPTS = T.let(T.unsafe(nil), Integer)

# source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:59
class Sidekiq::JobRetry::Handled < ::RuntimeError; end

# source://sidekiq-5.2.10/lib/sidekiq/job_retry.rb:60
class Sidekiq::JobRetry::Skip < ::Sidekiq::JobRetry::Handled; end

# source://sidekiq-5.2.10/lib/sidekiq/api.rb:555
class Sidekiq::JobSet < ::Sidekiq::SortedSet
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:617
  def delete(score, jid); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:617
  def delete_by_jid(score, jid); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:609
  def delete_by_value(name, value); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:563
  def each; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:584
  def fetch(score, jid = T.unsafe(nil)); end

  # Find the job with the given JID within this sorted set.
  #
  # This is a slow, inefficient operation.  Do not use under
  # normal conditions.  Sidekiq Pro contains a faster version.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:605
  def find_job(jid); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:557
  def schedule(timestamp, message); end
end

# source://sidekiq-5.2.10/lib/sidekiq.rb:16
Sidekiq::LICENSE = T.let(T.unsafe(nil), String)

# The Launcher is a very simple Actor whose job is to
# start, monitor and stop the core Actors in Sidekiq.
# If any of these actors die, the Sidekiq process exits
# immediately.
#
# source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:11
class Sidekiq::Launcher
  include ::Sidekiq::ExceptionHandler
  include ::Sidekiq::Util

  # @return [Launcher] a new instance of Launcher
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:18
  def initialize(options); end

  # Returns the value of attribute fetcher.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:14
  def fetcher; end

  # Sets the attribute fetcher
  #
  # @param value the value to set the attribute fetcher to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:14
  def fetcher=(_arg0); end

  # Returns the value of attribute manager.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:14
  def manager; end

  # Sets the attribute manager
  #
  # @param value the value to set the attribute manager to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:14
  def manager=(_arg0); end

  # Returns the value of attribute poller.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:14
  def poller; end

  # Sets the attribute poller
  #
  # @param value the value to set the attribute poller to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:14
  def poller=(_arg0); end

  # Stops this instance from processing any more jobs,
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:33
  def quiet; end

  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:25
  def run; end

  # Shuts down the process.  This method does not
  # return until all work is complete and cleaned up.
  # It can take up to the timeout to complete.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:42
  def stop; end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:59
  def stopping?; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:158
  def clear_heartbeat; end

  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:65
  def heartbeat; end

  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:127
  def start_heartbeat; end

  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:135
  def to_data; end

  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:150
  def to_json; end

  # source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:73
  def â¤; end
end

# source://sidekiq-5.2.10/lib/sidekiq/launcher.rb:16
Sidekiq::Launcher::STATS_TTL = T.let(T.unsafe(nil), Integer)

# source://sidekiq-5.2.10/lib/sidekiq/logging.rb:7
module Sidekiq::Logging
  # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:118
  def logger; end

  class << self
    # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:53
    def initialize_logger(log_target = T.unsafe(nil)); end

    # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:33
    def job_hash_context(job_hash); end

    # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:62
    def logger; end

    # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:66
    def logger=(log); end

    # This reopens ALL logfiles in the process that have been rotated
    # using logrotate(8) (without copytruncate) or similar tools.
    # A +File+ object is considered for reopening if it is:
    #   1) opened with the O_APPEND and O_WRONLY flags
    #   2) the current open file handle does not match its original open path
    #   3) unbuffered (as far as userspace buffering goes, not O_SYNC)
    # Returns the number of files reopened
    #
    # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:77
    def reopen_logs; end

    # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:29
    def tid; end

    # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:45
    def with_context(msg); end

    # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:41
    def with_job_hash_context(job_hash, &block); end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/logging.rb:9
class Sidekiq::Logging::Pretty < ::Logger::Formatter
  # Provide a call() method that returns the formatted message.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:13
  def call(severity, time, program_name, message); end

  # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:17
  def context; end
end

# source://sidekiq-5.2.10/lib/sidekiq/logging.rb:10
Sidekiq::Logging::Pretty::SPACE = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/logging.rb:23
class Sidekiq::Logging::WithoutTimestamp < ::Sidekiq::Logging::Pretty
  # source://sidekiq-5.2.10/lib/sidekiq/logging.rb:24
  def call(severity, time, program_name, message); end
end

# The Manager is the central coordination point in Sidekiq, controlling
# the lifecycle of the Processors.
#
# Tasks:
#
# 1. start: Spin up Processors.
# 3. processor_died: Handle job failure, throw away Processor, create new one.
# 4. quiet: shutdown idle Processors.
# 5. stop: hard stop the Processors by deadline.
#
# Note that only the last task requires its own Thread since it has to monitor
# the shutdown process.  The other tasks are performed by other threads.
#
# source://sidekiq-5.2.10/lib/sidekiq/manager.rb:24
class Sidekiq::Manager
  include ::Sidekiq::ExceptionHandler
  include ::Sidekiq::Util

  # @raise [ArgumentError]
  # @return [Manager] a new instance of Manager
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/manager.rb:3
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute options.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:28
  def options; end

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:90
  def processor_died(processor, reason); end

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:84
  def processor_stopped(processor); end

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:50
  def quiet; end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/manager.rb:8
  def start; end

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:62
  def stop(deadline); end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:101
  def stopped?; end

  # Returns the value of attribute workers.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:27
  def workers; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/manager.rb:107
  def hard_shutdown; end
end

# hack for quicker development / testing environment #2774
#
# source://sidekiq-5.2.10/lib/sidekiq/manager.rb:60
Sidekiq::Manager::PAUSE_TIME = T.let(T.unsafe(nil), Float)

# Middleware is code configured to run before/after
# a message is processed.  It is patterned after Rack
# middleware. Middleware exists for the client side
# (pushing jobs onto the queue) as well as the server
# side (when jobs are actually processed).
#
# To add middleware for the client:
#
# Sidekiq.configure_client do |config|
#   config.client_middleware do |chain|
#     chain.add MyClientHook
#   end
# end
#
# To modify middleware for the server, just call
# with another block:
#
# Sidekiq.configure_server do |config|
#   config.server_middleware do |chain|
#     chain.add MyServerHook
#     chain.remove ActiveRecord
#   end
# end
#
# To insert immediately preceding another entry:
#
# Sidekiq.configure_client do |config|
#   config.client_middleware do |chain|
#     chain.insert_before ActiveRecord, MyClientHook
#   end
# end
#
# To insert immediately after another entry:
#
# Sidekiq.configure_client do |config|
#   config.client_middleware do |chain|
#     chain.insert_after ActiveRecord, MyClientHook
#   end
# end
#
# This is an example of a minimal server middleware:
#
# class MyServerHook
#   def call(worker_instance, msg, queue)
#     puts "Before work"
#     yield
#     puts "After work"
#   end
# end
#
# This is an example of a minimal client middleware, note
# the method must return the result or the job will not push
# to Redis:
#
# class MyClientHook
#   def call(worker_class, msg, queue, redis_pool)
#     puts "Before push"
#     result = yield
#     puts "After push"
#     result
#   end
# end
#
# source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:66
module Sidekiq::Middleware; end

# source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:67
class Sidekiq::Middleware::Chain
  include ::Enumerable

  # @return [Chain] a new instance of Chain
  # @yield [_self]
  # @yieldparam _self [Sidekiq::Middleware::Chain] the object that the method was called on
  #
  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:79
  def initialize; end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:88
  def add(klass, *args); end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:120
  def clear; end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:75
  def each(&block); end

  # Returns the value of attribute entries.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:69
  def entries; end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:112
  def exists?(klass); end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:105
  def insert_after(oldklass, newklass, *args); end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:98
  def insert_before(oldklass, newklass, *args); end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:124
  def invoke(*args); end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:93
  def prepend(klass, *args); end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:84
  def remove(klass); end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:116
  def retrieve; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:71
  def initialize_copy(copy); end
end

# source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:137
class Sidekiq::Middleware::Entry
  # @return [Entry] a new instance of Entry
  #
  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:140
  def initialize(klass, *args); end

  # Returns the value of attribute klass.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:138
  def klass; end

  # source://sidekiq-5.2.10/lib/sidekiq/middleware/chain.rb:145
  def make_new; end
end

# source://sidekiq-5.2.10/lib/sidekiq.rb:15
Sidekiq::NAME = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/paginator.rb:3
module Sidekiq::Paginator
  # source://sidekiq-5.2.10/lib/sidekiq/paginator.rb:5
  def page(key, pageidx = T.unsafe(nil), page_size = T.unsafe(nil), opts = T.unsafe(nil)); end
end

# Sidekiq::Process represents an active Sidekiq process talking with Redis.
# Each process has a set of attributes which look like this:
#
# {
#   'hostname' => 'app-1.example.com',
#   'started_at' => <process start time>,
#   'pid' => 12345,
#   'tag' => 'myapp'
#   'concurrency' => 25,
#   'queues' => ['default', 'low'],
#   'busy' => 10,
#   'beat' => <last heartbeat>,
#   'identity' => <unique string identifying the process>,
# }
#
# source://sidekiq-5.2.10/lib/sidekiq/api.rb:829
class Sidekiq::Process
  # @return [Process] a new instance of Process
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:830
  def initialize(hash); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:842
  def [](key); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:858
  def dump_threads; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:846
  def identity; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:838
  def labels; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:850
  def quiet!; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:854
  def stop!; end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:862
  def stopping?; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:834
  def tag; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:868
  def signal(sig); end
end

# Enumerates the set of Sidekiq processes which are actively working
# right now.  Each process send a heartbeat to Redis every 5 seconds
# so this set should be relatively accurate, barring network partitions.
#
# Yields a Sidekiq::Process.
#
# source://sidekiq-5.2.10/lib/sidekiq/api.rb:734
class Sidekiq::ProcessSet
  include ::Enumerable
  include ::Sidekiq::RedisScanner

  # @return [ProcessSet] a new instance of ProcessSet
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:738
  def initialize(clean_plz = T.unsafe(nil)); end

  # Cleans up dead processes recorded in Redis.
  # Returns the number of processes cleaned.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:744
  def cleanup; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:766
  def each; end

  # Returns the identity of the current cluster leader or "" if no leader.
  # This is a Sidekiq Enterprise feature, will always return "" in Sidekiq
  # or Sidekiq Pro.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:804
  def leader; end

  # This method is not guaranteed accurate since it does not prune the set
  # based on current heartbeat.  #each does that and ensures the set only
  # contains Sidekiq processes which have sent a heartbeat within the last
  # 60 seconds.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:797
  def size; end
end

# The Processor is a standalone thread which:
#
# 1. fetches a job from Redis
# 2. executes the job
#   a. instantiate the Worker
#   b. run the middleware chain
#   c. call #perform
#
# A Processor can exit due to shutdown (processor_stopped)
# or due to an error during job execution (processor_died)
#
# If an error occurs in the job execution, the
# Processor calls the Manager to create a new one
# to replace itself and exits.
#
# source://sidekiq-5.2.10/lib/sidekiq/processor.rb:25
class Sidekiq::Processor
  include ::Sidekiq::ExceptionHandler
  include ::Sidekiq::Util

  # @return [Processor] a new instance of Processor
  #
  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:32
  def initialize(mgr); end

  # Returns the value of attribute job.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:30
  def job; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:50
  def kill(wait = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:62
  def start; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:44
  def terminate(wait = T.unsafe(nil)); end

  # Returns the value of attribute thread.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:29
  def thread; end

  private

  # Deep clone the arguments passed to the worker so that if
  # the job fails, what is pushed back onto Redis hasn't
  # been mutated by the worker.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:263
  def cloned(thing); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:267
  def constantize(str); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:118
  def dispatch(job_hash, queue); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:191
  def execute_job(worker, cloned_args); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:98
  def fetch; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:87
  def get_one; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:108
  def handle_fetch_exception(ex); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:146
  def process(work); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:81
  def process_one; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:68
  def run; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:245
  def stats(job_hash, queue); end
end

# Ruby doesn't provide atomic counters out of the box so we'll
# implement something simple ourselves.
# https://bugs.ruby-lang.org/issues/14706
#
# source://sidekiq-5.2.10/lib/sidekiq/processor.rb:198
class Sidekiq::Processor::Counter
  # @return [Counter] a new instance of Counter
  #
  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:199
  def initialize; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:204
  def incr(amount = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:208
  def reset; end
end

# source://sidekiq-5.2.10/lib/sidekiq/processor.rb:242
Sidekiq::Processor::FAILURE = T.let(T.unsafe(nil), Sidekiq::Processor::Counter)

# source://sidekiq-5.2.10/lib/sidekiq/processor.rb:241
Sidekiq::Processor::PROCESSED = T.let(T.unsafe(nil), Sidekiq::Processor::Counter)

# jruby's Hash implementation is not threadsafe, so we wrap it in a mutex here
#
# source://sidekiq-5.2.10/lib/sidekiq/processor.rb:214
class Sidekiq::Processor::SharedWorkerState
  # @return [SharedWorkerState] a new instance of SharedWorkerState
  #
  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:215
  def initialize; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:236
  def clear; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:224
  def delete(tid); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:228
  def dup; end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:220
  def set(tid, hash); end

  # source://sidekiq-5.2.10/lib/sidekiq/processor.rb:232
  def size; end
end

# source://sidekiq-5.2.10/lib/sidekiq/processor.rb:243
Sidekiq::Processor::WORKER_STATE = T.let(T.unsafe(nil), Sidekiq::Processor::SharedWorkerState)

# Encapsulates a queue within Sidekiq.
# Allows enumeration of all jobs within the queue
# and deletion of jobs.
#
#   queue = Sidekiq::Queue.new("mailer")
#   queue.each do |job|
#     job.klass # => 'MyWorker'
#     job.args # => [1, 2, 3]
#     job.delete if job.jid == 'abcdef1234567890'
#   end
#
# source://sidekiq-5.2.10/lib/sidekiq/api.rb:225
class Sidekiq::Queue
  include ::Enumerable
  extend ::Sidekiq::RedisScanner

  # @return [Queue] a new instance of Queue
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:238
  def initialize(name = T.unsafe(nil)); end

  # source://RUBY_ROOT/forwardable.rb:226
  def acquire(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def block(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def block_except(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def blocking?(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def busy(*args, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:298
  def clear; end

  # source://RUBY_ROOT/forwardable.rb:226
  def decrease_busy(*args, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:268
  def each; end

  # source://RUBY_ROOT/forwardable.rb:226
  def explain(*args, &block); end

  # Find the job with the given JID within this queue.
  #
  # This is a slow, inefficient operation.  Do not use under
  # normal conditions.  Sidekiq Pro contains a faster version.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:294
  def find_job(jid); end

  # source://RUBY_ROOT/forwardable.rb:226
  def increase_busy(*args, &block); end

  # Calculates this queue's latency, the difference in seconds since the oldest
  # job in the queue was enqueued.
  #
  # @return Float
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:257
  def latency; end

  # source://RUBY_ROOT/forwardable.rb:226
  def limit(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def limit=(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def limit_changed?(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def local_busy?(*args, &block); end

  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/queue.rb:19
  def lock; end

  # Returns the value of attribute name.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:236
  def name; end

  # source://RUBY_ROOT/forwardable.rb:226
  def pause(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def pause_for_ms(*args, &block); end

  # Sidekiq Pro overrides this
  #
  # @return [Boolean]
  #
  # source://RUBY_ROOT/forwardable.rb:226
  def paused?(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def probed(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def process_limit(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def process_limit=(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def release(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def remove_locks_except!(*args, &block); end

  # Returns the value of attribute rname.
  #
  # source://sidekiq-limit_fetch-3.4.0/lib/sidekiq/extensions/queue.rb:4
  def rname; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:243
  def size; end

  # source://RUBY_ROOT/forwardable.rb:226
  def unblock(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def unblocked(*args, &block); end

  # source://RUBY_ROOT/forwardable.rb:226
  def unpause(*args, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:298
  def ðŸ’£; end

  class << self
    # Return all known queues within Redis.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/api.rb:232
    def all; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/testing.rb:100
module Sidekiq::Queues
  class << self
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:167
    def [](queue); end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:194
    def clear_all; end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:189
    def clear_for(queue, klass); end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:184
    def delete_for(jid, queue, klass); end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:176
    def jobs_by_queue; end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:180
    def jobs_by_worker; end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:171
    def push(queue, klass, job); end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/rails.rb:11
class Sidekiq::Rails < ::Rails::Engine; end

# source://sidekiq-5.2.10/lib/sidekiq/rails.rb:36
class Sidekiq::Rails::Reloader
  # @return [Reloader] a new instance of Reloader
  #
  # source://sidekiq-5.2.10/lib/sidekiq/rails.rb:37
  def initialize(app = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/rails.rb:41
  def call; end

  # source://sidekiq-5.2.10/lib/sidekiq/rails.rb:47
  def inspect; end
end

# source://sidekiq-5.2.10/lib/sidekiq/redis_connection.rb:7
class Sidekiq::RedisConnection
  class << self
    # source://sidekiq-5.2.10/lib/sidekiq/redis_connection.rb:10
    def create(options = T.unsafe(nil)); end

    private

    # source://sidekiq-5.2.10/lib/sidekiq/redis_connection.rb:52
    def build_client(options); end

    # source://sidekiq-5.2.10/lib/sidekiq/redis_connection.rb:70
    def client_opts(options); end

    # source://sidekiq-5.2.10/lib/sidekiq/redis_connection.rb:111
    def determine_redis_provider; end

    # source://sidekiq-5.2.10/lib/sidekiq/redis_connection.rb:93
    def log_info(options); end

    # Sidekiq needs a lot of concurrent Redis connections.
    #
    # We need a connection for each Processor.
    # We need a connection for Pro's real-time change listener
    # We need a connection to various features to call Redis every few seconds:
    #   - the process heartbeat.
    #   - enterprise's leader election
    #   - enterprise's cron support
    #
    # @raise [ArgumentError]
    #
    # source://sidekiq-5.2.10/lib/sidekiq/redis_connection.rb:48
    def verify_sizing(size, concurrency); end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/api.rb:6
module Sidekiq::RedisScanner
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:7
  def sscan(conn, key); end
end

# Allows enumeration of retries within Sidekiq.
# Based on this, you can search/filter for jobs.  Here's an
# example where I'm selecting all jobs of a certain type
# and deleting them from the retry queue.
#
#   r = Sidekiq::RetrySet.new
#   r.select do |retri|
#     retri.klass == 'Sidekiq::Extensions::DelayedClass' &&
#     retri.args[0] == 'User' &&
#     retri.args[1] == 'setup_new_subscriber'
#   end.map(&:delete)
#
# source://sidekiq-5.2.10/lib/sidekiq/api.rb:665
class Sidekiq::RetrySet < ::Sidekiq::JobSet
  # @return [RetrySet] a new instance of RetrySet
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:666
  def initialize; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:676
  def kill_all; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:670
  def retry_all; end
end

# source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:7
module Sidekiq::Scheduled; end

# source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:10
class Sidekiq::Scheduled::Enq
  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:11
  def enqueue_jobs(now = T.unsafe(nil), sorted_sets = T.unsafe(nil)); end
end

# The Poller checks Redis every N seconds for jobs in the retry or scheduled
# set have passed their timestamp and should be enqueued.  If so, it
# just pops the job back onto its original queue so the
# workers can pick it up like any other job.
#
# source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:40
class Sidekiq::Scheduled::Poller
  include ::Sidekiq::ExceptionHandler
  include ::Sidekiq::Util

  # @return [Poller] a new instance of Poller
  #
  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:45
  def initialize; end

  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:75
  def enqueue; end

  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:63
  def start; end

  # Shut down this instance, will pause until the thread is dead.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:53
  def terminate; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:160
  def initial_wait; end

  # We do our best to tune the poll interval to the size of the active Sidekiq
  # cluster.  If you have 30 processes and poll every 15 seconds, that means one
  # Sidekiq is checking Redis every 0.5 seconds - way too often for most people
  # and really bad if the retry or scheduled sets are large.
  #
  # Instead try to avoid polling more than once every 15 seconds.  If you have
  # 30 Sidekiq processes, we'll poll every 30 * 15 or 450 seconds.
  # To keep things statistically random, we'll sleep a random amount between
  # 225 and 675 seconds for each poll or 450 seconds on average.  Otherwise restarting
  # all your Sidekiq processes at the same time will lead to them all polling at
  # the same time: the thundering herd problem.
  #
  # We only do this if poll_interval_average is unset (the default).
  #
  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:143
  def poll_interval_average; end

  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:154
  def process_count; end

  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:100
  def random_poll_interval; end

  # Calculates an average poll interval based on the number of known Sidekiq processes.
  # This minimizes a single point of failure by dispersing check-ins but without taxing
  # Redis if you run many Sidekiq processes.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:150
  def scaled_poll_interval; end

  # source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:88
  def wait; end
end

# source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:43
Sidekiq::Scheduled::Poller::INITIAL_WAIT = T.let(T.unsafe(nil), Integer)

# source://sidekiq-5.2.10/lib/sidekiq/scheduled.rb:8
Sidekiq::Scheduled::SETS = T.let(T.unsafe(nil), Array)

# Allows enumeration of scheduled jobs within Sidekiq.
# Based on this, you can search/filter for jobs.  Here's an
# example where I'm selecting all jobs of a certain type
# and deleting them from the schedule queue.
#
#   r = Sidekiq::ScheduledSet.new
#   r.select do |scheduled|
#     scheduled.klass == 'Sidekiq::Extensions::DelayedClass' &&
#     scheduled.args[0] == 'User' &&
#     scheduled.args[1] == 'setup_new_subscriber'
#   end.map(&:delete)
#
# source://sidekiq-5.2.10/lib/sidekiq/api.rb:647
class Sidekiq::ScheduledSet < ::Sidekiq::JobSet
  # @return [ScheduledSet] a new instance of ScheduledSet
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:648
  def initialize; end
end

# We are shutting down Sidekiq but what about workers that
# are working on some long job?  This error is
# raised in workers that have not finished within the hard
# timeout limit.  This is needed to rollback db transactions,
# otherwise Ruby's Thread#kill will commit.  See #377.
# DO NOT RESCUE THIS ERROR IN YOUR WORKERS
#
# source://sidekiq-5.2.10/lib/sidekiq.rb:234
class Sidekiq::Shutdown < ::Interrupt; end

# source://sidekiq-5.2.10/lib/sidekiq/api.rb:441
class Sidekiq::SortedEntry < ::Sidekiq::Job
  # @return [SortedEntry] a new instance of SortedEntry
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:445
  def initialize(parent, score, item); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:468
  def add_to_queue; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:451
  def at; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:455
  def delete; end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:491
  def error?; end

  # Place job in the dead set
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:485
  def kill; end

  # Returns the value of attribute parent.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:443
  def parent; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:463
  def reschedule(at); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:475
  def retry; end

  # Returns the value of attribute score.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:442
  def score; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:497
  def remove_job; end
end

# source://sidekiq-5.2.10/lib/sidekiq/api.rb:533
class Sidekiq::SortedSet
  include ::Enumerable

  # @return [SortedSet] a new instance of SortedSet
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:538
  def initialize(name); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:547
  def clear; end

  # Returns the value of attribute name.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:536
  def name; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:543
  def size; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:547
  def ðŸ’£; end
end

# source://sidekiq-5.2.10/lib/sidekiq/api.rb:19
class Sidekiq::Stats
  include ::Sidekiq::RedisScanner

  # @return [Stats] a new instance of Stats
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:22
  def initialize; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:42
  def dead_size; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:58
  def default_queue_latency; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:46
  def enqueued; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:30
  def failed; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:66
  def fetch_stats!; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:26
  def processed; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:50
  def processes_size; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:62
  def queues; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:120
  def reset(*stats); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:38
  def retry_size; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:34
  def scheduled_size; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:54
  def workers_size; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:136
  def stat(s); end
end

# source://sidekiq-5.2.10/lib/sidekiq/api.rb:165
class Sidekiq::Stats::History
  # @raise [ArgumentError]
  # @return [History] a new instance of History
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:166
  def initialize(days_previous, start_date = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:177
  def failed; end

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:173
  def processed; end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:183
  def date_stat_hash(stat); end
end

# source://sidekiq-5.2.10/lib/sidekiq/api.rb:140
class Sidekiq::Stats::Queues
  include ::Sidekiq::RedisScanner

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:143
  def lengths; end
end

# source://sidekiq-5.2.10/lib/sidekiq/testing.rb:7
class Sidekiq::Testing
  class << self
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:11
    def __set_test_mode(mode); end

    # Returns the value of attribute __test_mode.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:9
    def __test_mode; end

    # Sets the attribute __test_mode
    #
    # @param value the value to set the attribute __test_mode to.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:9
    def __test_mode=(_arg0); end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:59
    def constantize(str); end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:25
    def disable!(&block); end

    # @return [Boolean]
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:41
    def disabled?; end

    # @return [Boolean]
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:37
    def enabled?; end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:29
    def fake!(&block); end

    # @return [Boolean]
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:45
    def fake?; end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:33
    def inline!(&block); end

    # @return [Boolean]
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:49
    def inline?; end

    # @yield [@server_chain]
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:53
    def server_middleware; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/testing.rb:75
module Sidekiq::TestingClient
  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:76
  def raw_push(payloads); end
end

# This module is part of Sidekiq core and not intended for extensions.
#
# source://sidekiq-5.2.10/lib/sidekiq/util.rb:10
module Sidekiq::Util
  include ::Sidekiq::ExceptionHandler

  # source://sidekiq-5.2.10/lib/sidekiq/util.rb:49
  def fire_event(event, options = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/util.rb:37
  def hostname; end

  # source://sidekiq-5.2.10/lib/sidekiq/util.rb:45
  def identity; end

  # source://sidekiq-5.2.10/lib/sidekiq/util.rb:29
  def logger; end

  # source://sidekiq-5.2.10/lib/sidekiq/util.rb:41
  def process_nonce; end

  # source://sidekiq-5.2.10/lib/sidekiq/util.rb:33
  def redis(&block); end

  # source://sidekiq-5.2.10/lib/sidekiq/util.rb:22
  def safe_thread(name, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/util.rb:15
  def watchdog(last_words); end
end

# source://sidekiq-5.2.10/lib/sidekiq/util.rb:13
Sidekiq::Util::EXPIRY = T.let(T.unsafe(nil), Integer)

# source://sidekiq-5.2.10/lib/sidekiq/version.rb:3
Sidekiq::VERSION = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web.rb:20
class Sidekiq::Web
  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:111
  def app; end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:102
  def call(env); end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:119
  def disable(*opts); end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:115
  def enable(*opts); end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:98
  def middlewares; end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:132
  def sessions; end

  # Sets the attribute sessions
  #
  # @param value the value to set the attribute sessions to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:130
  def sessions=(_arg0); end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:123
  def set(attribute, value); end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:90
  def settings; end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:94
  def use(*middleware_args, &block); end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:176
  def build; end

  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:153
  def build_sessions; end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web.rb:147
  def using?(middleware); end

  class << self
    # Returns the value of attribute app_url.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:79
    def app_url; end

    # Sets the attribute app_url
    #
    # @param value the value to set the attribute app_url to.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:79
    def app_url=(_arg0); end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:106
    def call(env); end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:53
    def custom_tabs; end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:49
    def default_tabs; end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:70
    def disable(*opts); end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:66
    def enable(*opts); end

    # @private
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:83
    def inherited(child); end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:58
    def locales; end

    # Sets the attribute locales
    #
    # @param value the value to set the attribute locales to.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:80
    def locales=(_arg0); end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:41
    def middlewares; end

    # Returns the value of attribute redis_pool.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:79
    def redis_pool; end

    # Sets the attribute redis_pool
    #
    # @param value the value to set the attribute redis_pool to.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:79
    def redis_pool=(_arg0); end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:141
    def register(extension); end

    # Returns the value of attribute session_secret.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:79
    def session_secret; end

    # Sets the attribute session_secret
    #
    # @param value the value to set the attribute session_secret to.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:79
    def session_secret=(_arg0); end

    # Returns the value of attribute sessions.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:79
    def sessions; end

    # Sets the attribute sessions
    #
    # @param value the value to set the attribute sessions to.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:79
    def sessions=(_arg0); end

    # Helper for the Sinatra syntax: Sidekiq::Web.set(:session_secret, Rails.application.secrets...)
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:75
    def set(attribute, value); end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:37
    def settings; end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:53
    def tabs; end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:45
    def use(*middleware_args, &block); end

    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:62
    def views; end

    # Sets the attribute views
    #
    # @param value the value to set the attribute views to.
    #
    # source://sidekiq-5.2.10/lib/sidekiq/web.rb:80
    def views=(_arg0); end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/web.rb:25
Sidekiq::Web::ASSETS = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web.rb:27
Sidekiq::Web::DEFAULT_TABS = T.let(T.unsafe(nil), Hash)

# source://sidekiq-5.2.10/lib/sidekiq/web.rb:24
Sidekiq::Web::LAYOUT = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web.rb:23
Sidekiq::Web::LOCALES = T.let(T.unsafe(nil), Array)

# source://sidekiq-5.2.10/lib/sidekiq/web.rb:21
Sidekiq::Web::ROOT = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web.rb:22
Sidekiq::Web::VIEWS = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:4
class Sidekiq::WebAction
  include ::Sidekiq::WebHelpers
  include ::Sidekiq::Paginator

  # @return [WebAction] a new instance of WebAction
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:70
  def initialize(env, block); end

  def _render; end

  # Returns the value of attribute block.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:7
  def block; end

  # Sets the attribute block
  #
  # @param value the value to set the attribute block to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:7
  def block=(_arg0); end

  # Returns the value of attribute env.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:7
  def env; end

  # Sets the attribute env
  #
  # @param value the value to set the attribute env to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:7
  def env=(_arg0); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:42
  def erb(content, options = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:17
  def halt(res); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:66
  def json(payload); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:25
  def params; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:21
  def redirect(location); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:60
  def render(engine, content, options = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:13
  def request; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:34
  def route_params; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:38
  def session; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:9
  def settings; end

  # Returns the value of attribute type.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:7
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:7
  def type=(_arg0); end

  private

  # source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:79
  def _erb(file, locals); end
end

# source://sidekiq-5.2.10/lib/sidekiq/web/action.rb:5
Sidekiq::WebAction::RACK_SESSION = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:4
class Sidekiq::WebApplication
  extend ::Sidekiq::WebRouter

  # @return [WebApplication] a new instance of WebApplication
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:26
  def initialize(klass); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:282
  def call(env); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:30
  def settings; end

  class << self
    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:331
    def after(path = T.unsafe(nil), &block); end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:352
    def afters; end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:327
    def before(path = T.unsafe(nil), &block); end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:348
    def befores; end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:319
    def helpers(mod = T.unsafe(nil), &block); end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:339
    def run_afters(app, action); end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:335
    def run_befores(app, action); end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:343
    def run_hooks(hooks, app, action); end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:42
    def set(key, val); end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:34
    def settings; end

    # source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:38
    def tabs; end
  end
end

# source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:7
Sidekiq::WebApplication::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:8
Sidekiq::WebApplication::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:10
Sidekiq::WebApplication::CSP_HEADER = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/application.rb:9
Sidekiq::WebApplication::REDIS_KEYS = T.let(T.unsafe(nil), Array)

# This is not a public API
#
# source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:9
module Sidekiq::WebHelpers
  # This view helper provide ability display you html code in
  # to head of page. Example:
  #
  #   <% add_to_head do %>
  #     <link rel="stylesheet" .../>
  #     <meta .../>
  #   <% end %>
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:56
  def add_to_head; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:36
  def available_locales; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:24
  def clear_caches; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:222
  def csrf_tag; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:169
  def current_path; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:173
  def current_status; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:317
  def delete_or_add_queue(job, params); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:209
  def display_args(args, truncate_after_chars = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:61
  def display_custom_head; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:286
  def environment_title_prefix; end

  # This is a hook for a Sidekiq Pro feature.  Please don't touch.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:45
  def filtering(*_arg0); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:40
  def find_locale_files(lang); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:119
  def get_locale; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:266
  def h(text); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:182
  def job_params(job, score); end

  # Given an Accept-Language header like "fr-FR,fr;q=0.8,en-US;q=0.6,en;q=0.4,ru;q=0.2"
  # this method will try to best match the available locales to the user's preferred languages.
  #
  # Inspiration taken from https://github.com/iain/http_accept_language/blob/master/lib/http_accept_language/parser.rb
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:98
  def locale; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:30
  def locale_files; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:157
  def namespace; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:253
  def number_with_delimiter(number); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:186
  def parse_params(params); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:65
  def poll_path; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:136
  def processes; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:292
  def product_version; end

  # Merge options with current params, filter safe params, and stringify to query string
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:194
  def qparams(options); end

  # Any paginated list that performs an action needs to redirect
  # back to the proper page after performing that action.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:276
  def redirect_with_query(url); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:150
  def redis_connection; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:300
  def redis_connection_and_namespace; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:161
  def redis_info; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:177
  def relative_time(time); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:144
  def retries_with_score(score); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:245
  def retry_extra_items(retry_job); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:307
  def retry_or_delete_or_kill(job, params); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:165
  def root_path; end

  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:77
  def rtl?; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:296
  def server_utc_time; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:140
  def stats; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:10
  def strings(lang); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:123
  def t(msg, options = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:73
  def text_direction; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:226
  def to_display(arg); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:205
  def truncate(text, truncate_after_chars = T.unsafe(nil)); end

  # mperham/sidekiq#3243
  #
  # @return [Boolean]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:115
  def unfiltered?; end

  # See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:82
  def user_preferred_languages; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:132
  def workers; end
end

# source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:238
Sidekiq::WebHelpers::RETRY_JOB_KEYS = T.let(T.unsafe(nil), Set)

# source://sidekiq-5.2.10/lib/sidekiq/web/helpers.rb:191
Sidekiq::WebHelpers::SAFE_QPARAMS = T.let(T.unsafe(nil), Array)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:64
class Sidekiq::WebRoute
  # @return [WebRoute] a new instance of WebRoute
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:69
  def initialize(request_method, pattern, block); end

  # Returns the value of attribute block.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:65
  def block; end

  # Sets the attribute block
  #
  # @param value the value to set the attribute block to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:65
  def block=(_arg0); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:79
  def compile; end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:89
  def match(request_method, path); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:75
  def matcher; end

  # Returns the value of attribute name.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:65
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:65
  def name=(_arg0); end

  # Returns the value of attribute pattern.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:65
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:65
  def pattern=(_arg0); end

  # Returns the value of attribute request_method.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:65
  def request_method; end

  # Sets the attribute request_method
  #
  # @param value the value to set the attribute request_method to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:65
  def request_method=(_arg0); end
end

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:67
Sidekiq::WebRoute::NAMED_SEGMENTS_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:5
module Sidekiq::WebRouter
  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:33
  def delete(path, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:17
  def get(path, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:44
  def match(env); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:29
  def patch(path, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:21
  def post(path, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:25
  def put(path, &block); end

  # source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:37
  def route(method, path, &block); end
end

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:7
Sidekiq::WebRouter::DELETE = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:6
Sidekiq::WebRouter::GET = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:11
Sidekiq::WebRouter::HEAD = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:10
Sidekiq::WebRouter::PATCH = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:15
Sidekiq::WebRouter::PATH_INFO = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:8
Sidekiq::WebRouter::POST = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:9
Sidekiq::WebRouter::PUT = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:14
Sidekiq::WebRouter::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://sidekiq-5.2.10/lib/sidekiq/web/router.rb:13
Sidekiq::WebRouter::ROUTE_PARAMS = T.let(T.unsafe(nil), String)

# Include this module in your worker class and you can easily create
# asynchronous jobs:
#
#   class HardWorker
#     include Sidekiq::Worker
#
#     def perform(*args)
#       # do some work
#     end
#   end
#
# Then in your Rails app, you can do this:
#
#   HardWorker.perform_async(1, 2, 3)
#
# Note that perform_async is a class method, perform is an instance method.
#
# source://sidekiq-5.2.10/lib/sidekiq/worker.rb:23
module Sidekiq::Worker
  mixes_in_class_methods ::Sidekiq::Worker::ClassMethods

  # Returns the value of attribute jid.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:24
  def jid; end

  # Sets the attribute jid
  #
  # @param value the value to set the attribute jid to.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:24
  def jid=(_arg0); end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:35
  def logger; end

  class << self
    # Clear all queued jobs across all workers
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:311
    def clear_all; end

    # Drain all queued jobs across all workers
    #
    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:316
    def drain_all; end

    # @private
    # @raise [ArgumentError]
    #
    # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:26
    def included(base); end

    # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:306
    def jobs; end
  end
end

# The Sidekiq testing infrastructure overrides perform_async
# so that it does not actually touch the network.  Instead it
# stores the asynchronous jobs in a per-class array so that
# their presence/absence can be asserted by your tests.
#
# This is similar to ActionMailer's :test delivery_method and its
# ActionMailer::Base.deliveries array.
#
# Example:
#
#   require 'sidekiq/testing'
#
#   assert_equal 0, HardWorker.jobs.size
#   HardWorker.perform_async(:something)
#   assert_equal 1, HardWorker.jobs.size
#   assert_equal :something, HardWorker.jobs[0]['args'][0]
#
#   assert_equal 0, Sidekiq::Extensions::DelayedMailer.jobs.size
#   MyMailer.delay.send_welcome_email('foo@example.com')
#   assert_equal 1, Sidekiq::Extensions::DelayedMailer.jobs.size
#
# You can also clear and drain all workers' jobs:
#
#   assert_equal 0, Sidekiq::Extensions::DelayedMailer.jobs.size
#   assert_equal 0, Sidekiq::Extensions::DelayedModel.jobs.size
#
#   MyMailer.delay.send_welcome_email('foo@example.com')
#   MyModel.delay.do_something_hard
#
#   assert_equal 1, Sidekiq::Extensions::DelayedMailer.jobs.size
#   assert_equal 1, Sidekiq::Extensions::DelayedModel.jobs.size
#
#   Sidekiq::Worker.clear_all # or .drain_all
#
#   assert_equal 0, Sidekiq::Extensions::DelayedMailer.jobs.size
#   assert_equal 0, Sidekiq::Extensions::DelayedModel.jobs.size
#
# This can be useful to make sure jobs don't linger between tests:
#
#   RSpec.configure do |config|
#     config.before(:each) do
#       Sidekiq::Worker.clear_all
#     end
#   end
#
# or for acceptance testing, i.e. with cucumber:
#
#   AfterStep do
#     Sidekiq::Worker.drain_all
#   end
#
#   When I sign up as "foo@example.com"
#   Then I should receive a welcome email to "foo@example.com"
#
# source://sidekiq-5.2.10/lib/sidekiq/worker.rb:73
module Sidekiq::Worker::ClassMethods
  # Clear all jobs for this worker
  #
  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:270
  def clear; end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:142
  def client_push(item); end

  # @raise [ArgumentError]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:76
  def delay(*args); end

  # @raise [ArgumentError]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:80
  def delay_for(*args); end

  # @raise [ArgumentError]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:84
  def delay_until(*args); end

  # Drain and run all jobs for this worker
  #
  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:275
  def drain; end

  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:300
  def execute_job(worker, args); end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:138
  def get_sidekiq_options; end

  # Jobs queued for this worker
  #
  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:265
  def jobs; end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:92
  def perform_async(*args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:98
  def perform_at(interval, *args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:98
  def perform_in(interval, *args); end

  # Pop out a single job and perform it
  #
  # @raise [EmptyQueueError]
  #
  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:284
  def perform_one; end

  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:291
  def process_job(job); end

  # Queue for this worker
  #
  # source://sidekiq-5.2.10/lib/sidekiq/testing.rb:260
  def queue; end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:88
  def set(options); end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:152
  def sidekiq_class_attribute(*attrs); end

  # Allows customization for this type of Worker.
  # Legal options:
  #
  #   queue - use a named queue for this Worker, default 'default'
  #   retry - enable the RetryJobs middleware for this Worker, *true* to use the default
  #      or *Integer* count
  #   backtrace - whether to save any error backtrace in the retry payload to display in web UI,
  #      can be true, false or an integer number of lines to save, default *false*
  #   pool - use the given Redis connection pool to push this type of job to a given shard.
  #
  # In practice, any option is allowed.  This is the main mechanism to configure the
  # options for a specific job.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:125
  def sidekiq_options(opts = T.unsafe(nil)); end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:134
  def sidekiq_retries_exhausted(&block); end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:130
  def sidekiq_retry_in(&block); end
end

# source://sidekiq-5.2.10/lib/sidekiq/worker.rb:74
Sidekiq::Worker::ClassMethods::ACCESSOR_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# This helper class encapsulates the set options for `set`, e.g.
#
#     SomeWorker.set(queue: 'foo').perform_async(....)
#
# source://sidekiq-5.2.10/lib/sidekiq/worker.rb:43
class Sidekiq::Worker::Setter
  # @return [Setter] a new instance of Setter
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:44
  def initialize(klass, opts); end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:54
  def perform_async(*args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:60
  def perform_at(interval, *args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:60
  def perform_in(interval, *args); end

  # source://sidekiq-5.2.10/lib/sidekiq/worker.rb:49
  def set(options); end
end

# A worker is a thread that is currently processing a job.
# Programmatic access to the current active worker set.
#
# WARNING WARNING WARNING
#
# This is live data that can change every millisecond.
# If you call #size => 5 and then expect #each to be
# called 5 times, you're going to have a bad time.
#
#    workers = Sidekiq::Workers.new
#    workers.size => 2
#    workers.each do |process_id, thread_id, work|
#      # process_id is a unique identifier per Sidekiq process
#      # thread_id is a unique identifier per thread
#      # work is a Hash which looks like:
#      # { 'queue' => name, 'run_at' => timestamp, 'payload' => msg }
#      # run_at is an epoch Integer.
#    end
#
# source://sidekiq-5.2.10/lib/sidekiq/api.rb:900
class Sidekiq::Workers
  include ::Enumerable
  include ::Sidekiq::RedisScanner

  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:904
  def each; end

  # Note that #size is only as accurate as Sidekiq's heartbeat,
  # which happens every 5 seconds.  It is NOT real-time.
  #
  # Not very efficient if you have lots of Sidekiq
  # processes but the alternative is a global counter
  # which can easily get out of sync with crashy processes.
  #
  # source://sidekiq-5.2.10/lib/sidekiq/api.rb:926
  def size; end
end
